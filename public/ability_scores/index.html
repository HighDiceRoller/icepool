<!DOCTYPE html>
<html>

<head>
    <title>Ability score calculator</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" type="image/png" href="../die.png">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.18.0/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
</head>

<body>
    <h1>Ability score rolling method calculator</h1>
    
    <form id="single_array_inputs">
        Generate each ability score by rolling
        <input name="num_dice" id="num_dice" type="number" min="1" max="12" value="4" required onwheel="" />d<input name="die_size" id="die_size" type="number" min="2" max="20" value="6" required onwheel="" />,
        keeping the <input name="num_keep" id="num_keep" type="number" min="1" max="12" value="3" required onwheel="" /> highest dice, then adding
        <input name="modifier" id="modifier" type="number" min="-15" max="15" value="0" required onwheel="" />.<br/>
        Generate each ability score <input name="num_ability_repeat" id="num_ability_repeat" type="number" min="1" max="24" value="1" required onwheel="" /> time(s) and keep the highest.<br/>
        Generate <input name="num_abilities" id="num_abilities" type="number" min="6" max="24" value="6" required onwheel="" /> ability scores, keeping the 6 highest.<br/>
        Any scores less than 3 are set to 3 and any scores greater than 18 are set to 18.
    </form>
        
    <h2>Probability distribution of the 6 ranked ability scores</h2>
    
    <div style="width: 80%; margin: auto;">
        <canvas id="rankChart"></canvas>
    </div>

    <table id="rankTable" style="margin: auto;">
        <tr id="rankTableHeader">
            <th style="width: 8em; text-align: right;">Rank</th>
            <th style="width: 4em;">Mean</th>
        </tr>
        <tr id="rankTableRow1"><td>Rank 1</td></tr>
        <tr id="rankTableRow2"><td>Rank 2</td></tr>
        <tr id="rankTableRow3"><td>Rank 3</td></tr>
        <tr id="rankTableRow4"><td>Rank 4</td></tr>
        <tr id="rankTableRow5"><td>Rank 5</td></tr>
        <tr id="rankTableRow6"><td>Rank 6</td></tr>
        <tr id="rankTableRow0"><td>Top 6 overall</td></tr>
    </table>
    
    <h2>Multiple arrays</h2>
    
    <form id="multiple_array_inputs">
        Roll <input name="num_arrays" id="num_arrays" type="number" min="1" max="24" value="1" required onwheel="" /> array(s) and keep the best.
    </form>
    <table>
        <tr>
            <th style="text-align: left;">Pricing method</th>
            <th style="width: 4em;">Mean</th>
            <th style="width: 4em;">SD</th>
        </tr>
        <tr>
            <td>Raw total</td>
            <td id="mean_raw"></td>
            <td id="sd_raw"></td>
        </tr>
        <tr>
            <td><i>D&#38;D</i> 5e point buy (<a href="https://chicken-dinner.com/5e/5e-point-buy.html">ref</a>)</td>
            <td id="mean_5e"></td>
            <td id="sd_5e"></td>
        </tr>
        <tr>
            <td><i>Pathfinder</i> point buy (<a href="https://www.reddit.com/r/Pathfinder_RPG/comments/5owftt/closest_equivalent_point_buy_value_for_several/">ref</a>)</td>
            <td id="mean_pf"></td>
            <td id="sd_pf"></td>
        </tr>
    </table>
    
    <div style="max-width:1280px;">
        <h2>Notes</h2>
        
        <ul>
            <li>The six ranked dice are not independent; for example, if you roll a 14 as your highest score, you certainly can't have rolled a 15 as your second-highest score.</li>
            <li>Odd die sizes can be used to do things like "3d6, reroll all 1s", which is the same as 3d5+3.</li>
            <li><i>Pathfinder</i> point values are mostly equal to 2 less than <i>D&#38;D</i> 5e (per score); however, even beyond this, the references I used assign different values to scores below 8.</li>
        </ul>
        
        <h2>How does it work?</h2>
        
        <p>
            This webpage was built using <a href="https://pyodide.org/en/stable/">Pyodide</a>, <a href="https://www.chartjs.org/">Chart.js</a>, 
            and of course, my own <a href="https://gitlab.com/highdiceroller/hdroller">hdroller</a> Python library.
            <a href="https://gitlab.com/highdiceroller/hdroller/-/wikis/roll%20and%20keep%20computing">A polynomial-time keep-highest algorithm</a> 
            allows this calculator to deliver precise results at an interactive rate.
        </p>
        
        <p>
            Compare previous <a href="https://anydice.com/articles/4d6-drop-lowest">AnyDice</a> 
            and <a href="https://www.reddit.com/r/Pathfinder_RPG/comments/5owftt/closest_equivalent_point_buy_value_for_several/">Monte Carlo</a> approaches.
        </p>
        
        <p>
            If you want to play with hdroller more directly, <a href="https://starboard.gg/nb/nSMJ7hH">try this example Starboard notebook</a>,
            which computes the distributions of the total ability scores generated by the four <i>Advanced Dungeons &#38; Dragons</i> 1st Edition methods.
        </p>
    </div>
    
    <script type="text/javascript">
        // Populate form.
        let searchParams = new URLSearchParams(window.location.search);
        searchParams.forEach(function(value, key) {
            let n = parseInt(value);
            let field = $("#" + key);
            if (!(n >= field.attr('min') && n <= field.attr('max'))) {
                return;
            }
            field.val(value);
        });
        
        async function initPyodide(){
            let pyodide = await loadPyodide({
                indexURL : "https://cdn.jsdelivr.net/pyodide/v0.18.0/full/"
            });
            await pyodide.loadPackage("micropip");
            await pyodide.runPythonAsync(`
                import micropip
                await micropip.install('hdroller')
            `);
            return pyodide;
        }
        let pyodideReadyPromise = initPyodide();
        
        var maxProb = 1.0;
        
        var rankChartContext = document.getElementById('rankChart').getContext('2d');
        var rankChart = new Chart(rankChartContext, {
            type: 'line',
            data: {
                labels: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
                datasets: [],
            },
            options: {
                responsive: true,
                interaction: {
                    intersect: false,
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Ability score',
                        },
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Chance (%)',
                        },
                    },
                },
                plugins: {
                    title: {
                        text: "Loading...",
                        fullSize: true,
                        display : true,
                        font: {
                            size: 144,
                        },
                    },
                },
            },
        });
        
        let rankColors = [
            'rgba(120, 120, 120, 1.0)',
            'rgba(220, 0, 240, 1.0)',
            'rgba(0, 0, 240, 1.0)',
            'rgba(0, 200, 240, 1.0)',
            'rgba(0, 200, 0, 1.0)',
            'rgba(220, 200, 0, 1.0)',
            'rgba(220, 0, 0, 1.0)',
        ];
        
        for (let i = 0; i < 7; i++) {
            let label = 'Rank ' + i;
            if (i == 0) {
                label = 'Top 6 overall';
            }
            rankChart.data.datasets.push({
                label: label,
                borderColor: rankColors[i],
                data: rankChart.data.labels.map(x => 0.0),
            });
        }
        
        rankChart.update();
        
        // Build rank data table.
        for (let a = 3; a <= 18; a++) {
            $("<th>")
                .css('width', '4em')
                .text(a)
                .appendTo("#rankTableHeader");
        }
        
        async function updateRoll() {
            let pyodide = await pyodideReadyPromise;
            
            pyodide.runPython(`
            import js
            import numpy
            import pyodide
            from hdroller import Die
            
            point_buy_5e = numpy.array([-20, -16, -12, -9, -6, -4, -2, -1, 0, 1, 2, 3, 4, 5, 7, 9, 12, 15, 19])
            point_buy_pf = numpy.array([-30, -25, -20, -16, -12, -9, -6, -4, -2, -1, 0, 1, 2, 3, 5, 7, 10, 13, 17])
            
            num_dice = int(js.document.getElementById('num_dice').value);
            die_size = int(js.document.getElementById('die_size').value);
            num_keep = int(js.document.getElementById('num_keep').value);
            num_keep = min(num_keep, num_dice);
            modifier = int(js.document.getElementById('modifier').value);
            num_ability_repeat = int(js.document.getElementById('num_ability_repeat').value);
            num_abilities = int(js.document.getElementById('num_abilities').value);
            num_arrays = int(js.document.getElementById('num_arrays').value);
            
            single_ability = Die.d(die_size).keep_highest(num_dice, num_keep) + modifier
            single_ability = single_ability.clip(3, 18)
            single_ability = single_ability.keep_highest(num_ability_repeat)
            
            max_prob = 0.0
            ranks = []
            
            def set_rank_data(rank, die):
                data = numpy.zeros((16,))
                data[(single_ability.min_outcome()-3):(single_ability.max_outcome()-2)] = die.pmf() * 100.0
                js.rankChart.data.datasets[rank].data = pyodide.to_js([float(x) for x in data])
                if rank == 0:
                    name = 'Top 6 overall'
                else:
                    name = 'Rank %d' % rank
                table_text = '<td>%s</td><td>%0.2f</td>' % (name, die.mean())
                table_text += ''.join('<td>%0.2f%%</td>' % x for x in data)
                js.document.getElementById('rankTableRow%d' % rank).innerHTML = table_text
            
            for i in range(1, 7):
                rank_ability = single_ability.keep_index(num_abilities, num_abilities - i)
                ranks.append(rank_ability)
                set_rank_data(i, rank_ability)
                
                max_prob = max(max_prob, numpy.max(rank_ability.pmf()))
                
            set_rank_data(0, Die.mix(*ranks))
            
            js.maxProb = max_prob * 100.0
            
            def output_multiple_arrays(points, name):
                total = points.keep_highest(num_abilities, 6).keep_highest(num_arrays)
                js.document.getElementById('mean_' + name).innerHTML = '%0.2f' % total.mean()
                js.document.getElementById('sd_' + name).innerHTML = '%0.2f' % total.standard_deviation()
            
            single_ability_5e = single_ability.relabel(point_buy_5e[single_ability.outcomes()])
            single_ability_pf = single_ability.relabel(point_buy_pf[single_ability.outcomes()])
            
            output_multiple_arrays(single_ability, 'raw')
            output_multiple_arrays(single_ability_5e, '5e')
            output_multiple_arrays(single_ability_pf, 'pf')
            `);
            
            rankChart.options.plugins.title = {
                text: "",
                fullSize: false,
                display : false,
            };
            rankChart.update();
        }
        
        async function updateSearchQuery() {
            let searchParams = $("form").serialize();
            history.replaceState(null, "", "?" + searchParams);
        }
        
        updateRoll();
        updateSearchQuery();
        
        let single_array_inputs = document.querySelector('#single_array_inputs');
        single_array_inputs.addEventListener('input', updateRoll);
        single_array_inputs.addEventListener('input', updateSearchQuery);
        
        let multiple_array_inputs = document.querySelector('#multiple_array_inputs');
        multiple_array_inputs.addEventListener('input', updateRoll);
        multiple_array_inputs.addEventListener('input', updateSearchQuery);
    </script>
</body>

</html>
