<!DOCTYPE html>
<html>

<head>
    <title>Ability score calculator</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" type="image/png" href="../die.png">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.18.0/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
</head>

<body>
    <h1>Ability score rolling method calculator <span style="font-size:75%;">by HighDiceRoller</span></h1>
    
    <form id="single_array_inputs" style="border: 2px solid #dfdfdf; background-color: #efefefdf; position: -webkit-sticky; position: sticky; top: 0; z-index: 1">
        Generate each ability score by rolling
        <input name="num_dice" id="num_dice" type="number" min="1" max="12" value="4" required onwheel="" />d<input name="die_size" id="die_size" type="number" min="2" max="20" value="6" required onwheel="" />,
        keeping the <input name="num_keep" id="num_keep" type="number" min="1" max="12" value="3" required onwheel="" /> highest dice, then adding
        <input name="modifier" id="modifier" type="number" min="-15" max="15" value="0" required onwheel="" />.<br/>
        Generate each ability score <input name="num_ability_repeat" id="num_ability_repeat" type="number" min="1" max="24" value="1" required onwheel="" /> time(s) and keep the highest.<br/>
        Generate <input name="num_abilities" id="num_abilities" type="number" min="6" max="24" value="6" required onwheel="" /> ability scores, keeping the 6 highest.<br/>
        Any scores less than 3 are set to 3 and any scores greater than 18 are set to 18.
    </form>
        
    <h2>Probability distribution of the 6 highest ability scores</h2>
    
    <div style="width: 80%; margin: auto;">
        <canvas id="rankChart"></canvas>
    </div>

    <table id="rankTable" style="margin: auto;">
        <tr id="rankTableHeader">
            <th style="width: 8em; text-align: left;">Rank</th>
            <th style="width: 4em;">Mean</th>
            <th style="width: 4em;">3</th>
            <th style="width: 4em;">4</th>
            <th style="width: 4em;">5</th>
            <th style="width: 4em;">6</th>
            <th style="width: 4em;">7</th>
            <th style="width: 4em;">8</th>
            <th style="width: 4em;">9</th>
            <th style="width: 4em;">10</th>
            <th style="width: 4em;">11</th>
            <th style="width: 4em;">12</th>
            <th style="width: 4em;">13</th>
            <th style="width: 4em;">14</th>
            <th style="width: 4em;">15</th>
            <th style="width: 4em;">16</th>
            <th style="width: 4em;">17</th>
            <th style="width: 4em;">18</th>
        </tr>
        <tr id="rankTableRow0"><td style="text-align: left;">Highest</td></tr>
        <tr id="rankTableRow1"><td style="text-align: left;">2nd highest</td></tr>
        <tr id="rankTableRow2"><td style="text-align: left;">3rd highest</td></tr>
        <tr id="rankTableRow3"><td style="text-align: left;">4th highest</td></tr>
        <tr id="rankTableRow4"><td style="text-align: left;">5th highest</td></tr>
        <tr id="rankTableRow5"><td style="text-align: left;">6th highest</td></tr>
        <tr id="rankTableRow6"><td style="text-align: left;">Mean</td></tr>
    </table>
    
    <h2>Multiple arrays</h2>
    
    <p>(The preceding chart and table are for a single array.)</p>
    
    <form id="multiple_array_inputs">
        Roll <input name="num_arrays" id="num_arrays" type="number" min="1" max="24" value="1" required onwheel="" /> array(s) and keep the best.
    </form>
    
    <div style="width: 80%; margin: auto;">
        <div style="font-size: 150%;">
            Pricing method: 
            <select id="multiViewSelect">
                <option value="raw">Raw total</option>
                <option value="5e"><i>D&#38;D</i> 5e point buy</option>
                <option value="pf"><i>Pathfinder</i> point buy</option>
            </select>
        </div>
        <canvas id="multiChart"></canvas>
        <table style="margin: auto;">
            <tr>
                <th style="text-align: left;">Pricing method</th>
                <th style="width: 4em;">Mean</th>
                <th style="width: 4em;">SD</th>
            </tr>
            <tr>
                <td>Raw total</td>
                <td id="mean_raw"></td>
                <td id="sd_raw"></td>
            </tr>
            <tr>
                <td><i>D&#38;D</i> 5e point buy (<a href="https://chicken-dinner.com/5e/5e-point-buy.html">ref</a>)</td>
                <td id="mean_5e"></td>
                <td id="sd_5e"></td>
            </tr>
            <tr>
                <td><i>Pathfinder</i> point buy (<a href="https://www.reddit.com/r/Pathfinder_RPG/comments/5owftt/closest_equivalent_point_buy_value_for_several/">ref</a>)</td>
                <td id="mean_pf"></td>
                <td id="sd_pf"></td>
            </tr>
        </table>
    </div>
    
    
    
    <div style="max-width:1280px;">
        <h2>Notes</h2>
        
        <ul>
            <li>The mean of the six kept scores (grey line) is equal to picking one of those six scores uniformly at random.</li>
            <li>The six ranked dice are not independent; for example, if you roll a 14 as your highest score, you certainly can't have rolled a 15 as your second-highest score.</li>
            <li>Odd die sizes can be used to do things like "3d6, reroll all 1s", which is the same as 3d5+3.</li>
            <li><i>Pathfinder</i> point values are mostly equal to 2 less than <i>D&#38;D</i> 5e (per score); however, even beyond this, the references I used assign different values to scores below 8.</li>
            <li>Spikes are normal in the <i>D&#38;D</i> 5e and <i>Pathfinder</i> total point values, especially at the high end;
                this is because costs jump more than one point at a time, so some totals may have more or less possible/likely combinations of ability scores that add up to that total.
                In particular, this calculator uses a direct calculation; the spikes are real and <i>not</i> due to any sort of sample size phenomenon.</li>
        </ul>
        
        <h2>How does it work?</h2>
        
        <p>
            I built this using <a href="https://pyodide.org/en/stable/">Pyodide</a>, <a href="https://www.chartjs.org/">Chart.js</a>, 
            and of course, my own <a href="https://gitlab.com/highdiceroller/hdroller">hdroller</a> Python library.
            <a href="https://gitlab.com/highdiceroller/hdroller/-/wikis/roll%20and%20keep%20computing">A polynomial-time algorithm for keep-highest</a> 
            allows this calculator to deliver precise results at an interactive rate.
        </p>
        
        <p>
            Compare previous <a href="https://anydice.com/articles/4d6-drop-lowest">AnyDice</a> 
            and <a href="https://www.reddit.com/r/Pathfinder_RPG/comments/5owftt/closest_equivalent_point_buy_value_for_several/">Monte Carlo</a> approaches.
        </p>
        
        <p>
            If you want to play with hdroller more directly, <a href="https://starboard.gg/nb/nSMJ7hH">try this example Starboard notebook</a>,
            which computes the distributions of the total ability scores generated by the four <i>Advanced Dungeons &#38; Dragons</i> 1st Edition methods.
        </p>
    </div>
    
    <script type="text/javascript">
        // Populate form.
        let searchParams = new URLSearchParams(window.location.search);
        searchParams.forEach(function(value, key) {
            let n = parseInt(value);
            let field = $("#" + key);
            if (!(n >= field.attr('min') && n <= field.attr('max'))) {
                return;
            }
            field.val(value);
        });
        
        var maxProb = 1.0;
        
        var rankChartContext = document.getElementById('rankChart').getContext('2d');
        var rankChart = new Chart(rankChartContext, {
            type: 'line',
            data: {
                labels: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
                datasets: [],
            },
            options: {
                responsive: true,
                interaction: {
                    intersect: false,
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Ability score',
                        },
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Chance (%)',
                        },
                    },
                },
                plugins: {
                    title: {
                        fullSize: true,
                        display : true,
                        font: {
                            size: 36,
                        },
                    },
                },
            },
        });
        
        let rankColors = [
            'rgba(220, 0, 240, 1.0)',
            'rgba(0, 0, 240, 1.0)',
            'rgba(0, 200, 240, 1.0)',
            'rgba(0, 200, 0, 1.0)',
            'rgba(220, 200, 0, 1.0)',
            'rgba(220, 0, 0, 1.0)',
            'rgba(120, 120, 120, 1.0)',
        ];
        
        var rankLabels = [
            'Highest',
            '2nd highest',
            '3rd highest',
            '4th highest',
            '5th highest',
            '6th highest',
            'Mean',
        ];
        
        for (let i = 0; i < 7; i++) {
            rankChart.data.datasets.push({
                label: rankLabels[i],
                borderColor: rankColors[i],
                data: rankChart.data.labels.map(x => 0.0),
            });
        }
        
        var multiChartContext = document.getElementById('multiChart').getContext('2d');
        var multiChart = new Chart(multiChartContext, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Chance',
                        borderColor: 'rgba(0, 120, 0, 1.0)',
                        data: [],
                    },
                ],
            },
            options: {
                responsive: true,
                interaction: {
                    intersect: false,
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Total',
                        },
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Chance (%)',
                        },
                    },
                },
                plugins: {
                    title: {
                        fullSize: true,
                        display : true,
                        font: {
                            size: 36,
                        },
                    },
                    legend : {
                        display: false,
                    },
                },
            },
        });
        
        function setLoadingText(text) {
            if (!text.includes("Loading")) {
                return;
            }
            rankChart.options.plugins.title.text = text;
            multiChart.options.plugins.title.text = text;
            rankChart.update();
            multiChart.update();
        }
        
        async function initPyodide(){
            setLoadingText('Loading pyodide')
            let pyodide = await loadPyodide({
                indexURL : "https://cdn.jsdelivr.net/pyodide/v0.18.0/full/",
            });
            
            await pyodide.loadPackage(["micropip", "numpy", "scipy"], setLoadingText);
            
            setLoadingText('Loading hdroller')
            await pyodide.runPythonAsync(`
                import micropip
                await micropip.install('hdroller')
                
                import js
                import numpy
                import pyodide
                from hdroller import Die
                
                def set_rank_data(rank, die):
                    data = numpy.zeros((16,))
                    data[(single_ability.min_outcome()-3):(single_ability.max_outcome()-2)] = die.pmf() * 100.0
                    js.rankChart.data.datasets[rank].data = pyodide.to_js([float(x) for x in data])
                    table_text = '<td style="text-align: left;">%s</td><td>%0.2f</td>' % (js.rankLabels[rank], die.mean())
                    table_text += ''.join('<td>%0.2f%%</td>' % x for x in data)
                    js.document.getElementById('rankTableRow%d' % rank).innerHTML = table_text
                    
                def output_multiple_arrays(points, name):
                    total = points.keep_highest(num_abilities, 6).keep_highest(num_arrays)
                    js.document.getElementById('mean_' + name).innerHTML = '%0.2f' % total.mean()
                    js.document.getElementById('sd_' + name).innerHTML = '%0.2f' % total.standard_deviation()
                    return total
            `);
            
            rankChart.options.plugins.title = {
                text: "",
                fullSize: false,
                display : false,
            };
            
            multiChart.options.plugins.title = {
                text: "",
                fullSize: false,
                display : false,
            };
            return pyodide;
        }
        let pyodideReadyPromise = initPyodide();
        
        async function updateRoll() {
            let pyodide = await pyodideReadyPromise;
            
            pyodide.runPython(`

            point_buy_5e = numpy.array([-20, -16, -12, -9, -6, -4, -2, -1, 0, 1, 2, 3, 4, 5, 7, 9, 12, 15, 19])
            point_buy_pf = numpy.array([-30, -25, -20, -16, -12, -9, -6, -4, -2, -1, 0, 1, 2, 3, 5, 7, 10, 13, 17])
            
            num_dice = int(js.document.getElementById('num_dice').value);
            die_size = int(js.document.getElementById('die_size').value);
            num_keep = int(js.document.getElementById('num_keep').value);
            num_keep = min(num_keep, num_dice);
            modifier = int(js.document.getElementById('modifier').value);
            num_ability_repeat = int(js.document.getElementById('num_ability_repeat').value);
            num_abilities = int(js.document.getElementById('num_abilities').value);
            num_arrays = int(js.document.getElementById('num_arrays').value);
            
            single_ability = Die.d(die_size).keep_highest(num_dice, num_keep) + modifier
            single_ability = single_ability.clip(3, 18)
            single_ability = single_ability.keep_highest(num_ability_repeat)
            
            max_prob = 0.0
            ranks = []
            
            for i in range(6):
                rank_ability = single_ability.keep_index(num_abilities, num_abilities - 1 - i)
                ranks.append(rank_ability)
                set_rank_data(i, rank_ability)
                
                max_prob = max(max_prob, numpy.max(rank_ability.pmf()))
                
            set_rank_data(6, Die.mix(*ranks))
            
            js.maxProb = max_prob * 100.0
            
            single_ability_5e = single_ability.relabel(point_buy_5e[single_ability.outcomes()])
            single_ability_pf = single_ability.relabel(point_buy_pf[single_ability.outcomes()])
            
            total_raw = output_multiple_arrays(single_ability, 'raw')
            total_5e = output_multiple_arrays(single_ability_5e, '5e')
            total_pf = output_multiple_arrays(single_ability_pf, 'pf')
            `);
            
            rankChart.update();
        }
        
        async function updateMulti() {
            let pyodide = await pyodideReadyPromise;
            let rollReady = await rollReadyPromise;
            
            pyodide.runPython(`
                selected_view = js.document.getElementById('multiViewSelect').value
                if selected_view == '5e':
                    total_select = total_5e
                elif selected_view == 'pf':
                    total_select = total_pf
                else:
                    total_select = total_raw
                
                js.multiChart.data.labels = pyodide.to_js([float(x) for x in total_select.outcomes()])
                js.multiChart.data.datasets[0].data = pyodide.to_js([float(x * 100.0) for x in total_select.pmf()])
            `)

            multiChart.update();
        }
        
        async function updateSearchQuery() {
            let searchParams = $("form").serialize();
            history.replaceState(null, "", "?" + searchParams);
        }
        
        

        let rollReadyPromise = updateRoll();
        updateSearchQuery();
        updateMulti();
        
        let single_array_inputs = document.querySelector('#single_array_inputs');
        single_array_inputs.addEventListener('input', updateRoll);
        single_array_inputs.addEventListener('input', updateMulti);
        single_array_inputs.addEventListener('input', updateSearchQuery);
        
        let multiple_array_inputs = document.querySelector('#multiple_array_inputs');
        multiple_array_inputs.addEventListener('input', updateRoll);
        multiple_array_inputs.addEventListener('input', updateMulti);
        multiple_array_inputs.addEventListener('input', updateSearchQuery);
        
        let multiple_view_select = document.querySelector('#multiViewSelect');
        multiple_view_select.addEventListener('input', updateMulti);
    </script>
</body>

</html>
