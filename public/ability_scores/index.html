<!DOCTYPE html>
<html>

<head>
    <title>hdroller ability score calculator</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.18.0/full/pyodide.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h2>Ability scores</h2>
    
    <div id="inputs">
        <form>
            Generate each ability score by rolling
            <input id="num_dice" type="number" min="1" max="9" value="4" required onwheel="" />d<input id="die_size" type="number" min="4" max="20" value="6" required onwheel="" />,
            keeping the <input id="num_keep" type="number" min="1" max="9" value="3" required onwheel="" /> highest dice, then adding
            <input id="modifier" type="number" min="-9" max="9" value="0" required onwheel="" />.<br/>
            Generate <input id="num_abilities" type="number" min="6" max="24" value="6" required onwheel="" /> ability scores, keeping the 6 highest.
        </form>
    </div>
    
    <div id="outputs">
        <div id="rank_graph"></div>
        <p id="mean_array"></p>
    </div>
    
    <script type="text/javascript">
        async function init_pyodide(){
            let pyodide = await loadPyodide({
                indexURL : "https://cdn.jsdelivr.net/pyodide/v0.18.0/full/"
            });
            await pyodide.loadPackage("micropip");
            await pyodide.runPythonAsync(`
                import micropip
                await micropip.install('hdroller')
            `);
            return pyodide;
        }
        let pyodideReadyPromise = init_pyodide();
        
        var rank_svg = d3.select("#rank_graph")
            .append("svg")
                .attr("width", 1280)
                .attr("height", 640)
            .append("g")
                .attr("transform",
                      "translate(40, 20)");
        
        var loadingText = rank_svg
            .append("text")
                .attr("class", "loadingText")
                .attr("x", 600)
                .attr("y", 320)
                .text("Loading..."); 
        
        var rank_scale_x = d3.scaleLinear()
            .domain([3, 18])
            .range([0, 1200]);
        var rank_axis_x = d3.axisBottom().scale(rank_scale_x).ticks(15);
        rank_svg.append("g")
            .attr("transform", "translate(0, 600)")
            .attr("class", "rank_axis_x");
            
        var rank_scale_y = d3.scaleLinear()
            .domain([0, 20])
            .range([600, 0]);
        var rank_axis_y = d3.axisLeft().scale(rank_scale_y);
        rank_svg.append("g")
            .attr("class", "rank_axis_y");
        
        var rankColors = [
            "#df00ff",
            "#0000ff",
            "#00bfff",
            "#00bf00",
            "#dfbf00",
            "#df0000"
        ];
        var rankData = [];
        var rankLines = [];
        var maxProb = 1.0;
        for (let i = 0; i < 6; i++) {
            let data = [];
            for (let j = 3; j < 19; j++) {
                data.push([j, 1.0]);
            }
            let line = rank_svg.append("g").append("path")
                .datum(data)
                .attr("d", d3.line()
                    .x(function(d) { return rank_scale_x(d[0]) })
                    .y(function(d) { return rank_scale_y(d[1]) })
                )
                .attr("stroke", rankColors[i])
                .style("stroke-width", 4)
                .style("fill", "none");
            rankData.push(data);
            rankLines.push(line);
        }
        
        async function updateRoll() {
            let pyodide = await pyodideReadyPromise;
            
            pyodide.runPython(`
            import js
            import numpy
            import pyodide
            from hdroller import Die
            num_dice = int(js.document.getElementById('num_dice').value);
            die_size = int(js.document.getElementById('die_size').value);
            num_keep = int(js.document.getElementById('num_keep').value);
            num_keep = min(num_keep, num_dice);
            modifier = int(js.document.getElementById('modifier').value);
            num_abilities = int(js.document.getElementById('num_abilities').value);
            single_ability = Die.d(die_size).keep_highest(num_dice, num_keep) + modifier
            max_prob = 0.0
            ranks = []
            for i in range(6):
                rank_ability = single_ability.keep_index(num_abilities, num_abilities - 1 - i)
                ranks.append(rank_ability)
                js.rankData[i] = pyodide.to_js([[float(outcome), p * 100.0] for outcome, p in zip(rank_ability.outcomes(), rank_ability.pmf())])
                max_prob = max(max_prob, numpy.max(rank_ability.pmf()))
            
            js.maxProb = max_prob * 100.0
            js.document.getElementById('mean_array').innerHTML = 'Mean array: ' + ', '.join('%0.2f' % rank.mean() for rank in ranks)
            `);
            
            rank_scale_x.domain([rankData[5][0][0], rankData[5][rankData[5].length-1][0]]);
            rank_scale_y.domain([0, maxProb]);
            
            rank_svg.selectAll(".rank_axis_x").transition()
                .duration(500)
                .call(rank_axis_x);
            
            rank_svg.selectAll(".rank_axis_y").transition()
                .duration(500)
                .call(rank_axis_y);
                
            for (let i = 0; i < 6; i++) {
                rankLines[i]
                    .datum(rankData[i])
                    .transition()
                    .duration(500)
                    .attr("d", d3.line()
                        .x(function(d) { return rank_scale_x(d[0]) })
                        .y(function(d) { return rank_scale_y(d[1]) })
                    );
            }
            
            rank_svg.selectAll(".loadingText").text("");
        }
        
        updateRoll();
        
        let form = document.querySelector('form');
        form.addEventListener('change', updateRoll);
    </script>
</body>

</html>
