{"version":3,"file":"5932.04490e3.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drive.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/emscripten.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivecontents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/broadcast.js"],"sourcesContent":["import { PageConfig } from '@jupyterlab/coreutils';\nimport { Token } from '@lumino/coreutils';\nimport mime from 'mime';\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n/**\n * The token for the BroadcastChannel broadcaster.\n */\nexport const IBroadcastChannelWrapper = new Token('@jupyterlite/contents:IBroadcastChannelWrapper');\n//# sourceMappingURL=tokens.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { FILE, MIME } from './tokens';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The name of the drive.\n */\nexport const DRIVE_NAME = 'BrowserStorage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n/**\n * A custom drive to store files in the browser storage.\n */\nexport class BrowserStorageDrive {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        var _a;\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._isDisposed = false;\n        this._fileChanged = new Signal(this);\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        this._ready = new PromiseDelegate();\n        this.initialize().catch(console.warn);\n    }\n    /**\n     * Dispose the drive.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Whether the drive is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * The name of the drive.\n     */\n    get name() {\n        return DRIVE_NAME;\n    }\n    /**\n     * The server settings of the drive.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Signal emitted when a file operation takes place.\n     */\n    get fileChanged() {\n        return this._fileChanged;\n    }\n    /**\n     * Get the download URL\n     */\n    async getDownloadUrl(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     *\n     * TODO: keep private?\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname).catch(() => null);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: encoder.encode(JSON.stringify(Private.EMPTY_NB)).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                let ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                if (!ext.startsWith('.')) {\n                    ext = `.${ext}`;\n                }\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: file,\n        });\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${PathExt.removeSlash(toDir)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })\n            .then(() => true)\n            .catch(() => false)) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true }).catch(() => null);\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: item,\n        });\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            const folder = await this._getFolder(path);\n            if (folder === null) {\n                throw Error(`Could not find file with path ${path}`);\n            }\n            return folder;\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            throw Error(`Could not find content with path ${path}`);\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                size: 0,\n                ...model,\n                content: null,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true }).catch(() => null);\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        this._fileChanged.emit({\n            type: 'rename',\n            oldValue: { path: oldLocalPath },\n            newValue: newFile,\n        });\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        const chunk = options.chunk;\n        // retrieve the content if it is a later chunk or the last one\n        // the new content will then be appended to the existing one\n        const appendChunk = chunk ? chunk > 1 || chunk === -1 : false;\n        let item = await this.get(path, { content: appendChunk }).catch(() => null);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        // keep a reference to the original content\n        const originalContent = item.content;\n        const modified = new Date().toISOString();\n        // override with the new values\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            const lastChunk = chunk ? chunk === -1 : true;\n            const contentBinaryString = this._handleUploadChunk(options.content, originalContent, appendChunk);\n            if (ext === '.ipynb') {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'notebook',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                const content = lastChunk\n                    ? decoder.decode(this._binaryStringToBytes(contentBinaryString))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'text',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else {\n                const content = lastChunk ? btoa(contentBinaryString) : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'base64',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n        }\n        // fixup content sizes if necessary\n        if (item.content) {\n            switch (options.format) {\n                case 'json': {\n                    item = { ...item, size: encoder.encode(JSON.stringify(item.content)).length };\n                    break;\n                }\n                case 'text': {\n                    item = { ...item, size: encoder.encode(item.content).length };\n                    break;\n                }\n                // base64 save was already handled above\n                case 'base64': {\n                    break;\n                }\n                default: {\n                    item = { ...item, size: 0 };\n                    break;\n                }\n            }\n        }\n        else {\n            item = { ...item, size: 0 };\n        }\n        await (await this.storage).setItem(path, item);\n        this._fileChanged.emit({\n            type: 'save',\n            oldValue: null,\n            newValue: item,\n        });\n        return item;\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n        this._fileChanged.emit({\n            type: 'delete',\n            oldValue: { path },\n            newValue: null,\n        });\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true }).catch(() => null);\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * Handle an upload chunk for a file.\n     * each chunk is base64 encoded, so we need to decode it and append it to the\n     * original content.\n     * @param newContent the new content to process, base64 encoded\n     * @param originalContent the original content, must be null or a binary string if chunked is true\n     * @param appendChunk whether the chunk should be appended to the originalContent\n     *\n     *\n     * @returns the decoded binary string, appended to the original content if requested\n     * /\n     */\n    _handleUploadChunk(newContent, originalContent, appendChunk) {\n        const newContentBinaryString = atob(newContent);\n        const contentBinaryString = appendChunk\n            ? originalContent + newContentBinaryString\n            : newContentBinaryString;\n        return contentBinaryString;\n    }\n    /**\n     * Convert a binary string to an Uint8Array\n     * @param binaryString the binary string\n     * @returns the bytes of the binary string\n     */\n    _binaryStringToBytes(binaryString) {\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes;\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            size: 0,\n            content: '',\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: JSON.parse(contentText),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: contentText,\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else {\n                    const contentBuffer = await response.arrayBuffer();\n                    const contentBytes = new Uint8Array(contentBuffer);\n                    model = {\n                        ...model,\n                        content: btoa(contentBytes.reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                        size: contentBytes.length,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 5,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=drive.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/// <reference path=\"../../../node_modules/@types/emscripten/index.d.ts\" />\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport function instanceOfStream(nodeOrStream) {\n    return 'node' in nodeOrStream;\n}\n//# sourceMappingURL=emscripten.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DIR_MODE, SEEK_CUR, SEEK_END, instanceOfStream, } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    node(nodeOrStream) {\n        if (instanceOfStream(nodeOrStream)) {\n            return nodeOrStream.node;\n        }\n        return nodeOrStream;\n    }\n    getattr(value) {\n        const node = this.node(value);\n        return {\n            ...this.fs.API.getattr(this.fs.realPath(node)),\n            mode: node.mode,\n            ino: node.id,\n        };\n    }\n    setattr(value, attr) {\n        const node = this.node(value);\n        for (const [key, value] of Object.entries(attr)) {\n            switch (key) {\n                case 'mode':\n                    node.mode = value;\n                    break;\n                case 'timestamp':\n                    node.timestamp = value;\n                    break;\n                case 'size': {\n                    const size = value;\n                    const path = this.fs.realPath(node);\n                    if (this.fs.FS.isFile(node.mode) && size >= 0) {\n                        const file = this.fs.API.get(path);\n                        const oldData = file.data ? file.data : new Uint8Array();\n                        if (size !== oldData.length) {\n                            if (size < oldData.length) {\n                                file.data = file.data.slice(0, size);\n                            }\n                            else {\n                                file.data = new Uint8Array(size);\n                                file.data.set(oldData);\n                            }\n                            this.fs.API.put(path, file);\n                        }\n                    }\n                    else {\n                        console.warn('setattr size of', size, 'on', node, 'not yet implemented');\n                    }\n                    break;\n                }\n                default:\n                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                    break;\n            }\n        }\n    }\n    lookup(parent, name) {\n        const node = this.node(parent);\n        const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n        }\n        return this.fs.createNode(node, name, result.mode, 0);\n    }\n    mknod(parent, name, mode, dev) {\n        const node = this.node(parent);\n        const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(node, name, mode, dev);\n    }\n    rename(value, newDir, newName) {\n        const oldNode = this.node(value);\n        const newDirNode = this.node(newDir);\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDirNode;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n    }\n    readdir(value) {\n        return this.fs.API.readdir(this.fs.realPath(this.node(value)));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * ContentsAPI base class\n */\nexport class ContentsAPI {\n    constructor(driveName, mountpoint, FS, ERRNO_CODES) {\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return this.request({ method: 'getmode', path: this.normalizePath(path) });\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({\n            method: 'get',\n            path: this.normalizePath(path),\n        });\n        if (!response) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Turn datetimes into proper objects\n        if (stats.atime) {\n            stats.atime = new Date(stats.atime);\n        }\n        if (stats.mtime) {\n            stats.mtime = new Date(stats.mtime);\n        }\n        if (stats.ctime) {\n            stats.ctime = new Date(stats.ctime);\n        }\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n}\n/**\n * An Emscripten-compatible synchronous Contents API using the service worker.\n */\nexport class ServiceWorkerContentsAPI extends ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        super(driveName, mountpoint, FS, ERRNO_CODES);\n        this._baseUrl = baseUrl;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = this.createAPI(options);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    /**\n     * Create the ContentsAPI.\n     *\n     * This is supposed to be overwritten if needed.\n     */\n    createAPI(options) {\n        return new ServiceWorkerContentsAPI(options.baseUrl, options.driveName, options.mountpoint, options.FS, options.ERRNO_CODES);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","import { PathExt } from '@jupyterlab/coreutils';\nimport { BLOCK_SIZE } from './drivefs';\nimport { DIR_MODE, FILE_MODE } from './emscripten';\n/**\n * Class for processing a drive request from the DriveFS.\n */\nexport class DriveContentsProcessor {\n    constructor(options) {\n        this.contentsManager = options.contentsManager;\n    }\n    async processDriveRequest(request) {\n        switch (request.method) {\n            case 'readdir':\n                return this.readdir(request);\n            case 'rmdir':\n                return this.rmdir(request);\n            case 'rename':\n                return this.rename(request);\n            case 'getmode':\n                return this.getmode(request);\n            case 'lookup':\n                return this.lookup(request);\n            case 'mknod':\n                return this.mknod(request);\n            case 'getattr':\n                return this.getattr(request);\n            case 'get':\n                return this.get(request);\n            case 'put':\n                return this.put(request);\n        }\n        throw `Drive request ${request.method} does not exist.`;\n    }\n    async readdir(request) {\n        const model = await this.contentsManager.get(request.path, { content: true });\n        let response = [];\n        if (model.type === 'directory' && model.content) {\n            response = model.content.map((subcontent) => subcontent.name);\n        }\n        return response;\n    }\n    async rmdir(request) {\n        await this.contentsManager.delete(request.path);\n        return null;\n    }\n    async rename(request) {\n        await this.contentsManager.rename(request.path, request.data.newPath);\n        return null;\n    }\n    async getmode(request) {\n        const model = await this.contentsManager.get(request.path);\n        let response;\n        if (model.type === 'directory') {\n            response = DIR_MODE;\n        }\n        else {\n            response = FILE_MODE;\n        }\n        return response;\n    }\n    async lookup(request) {\n        let response;\n        try {\n            const model = await this.contentsManager.get(request.path);\n            response = {\n                ok: true,\n                mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n            };\n        }\n        catch (e) {\n            response = { ok: false };\n        }\n        return response;\n    }\n    async mknod(request) {\n        const model = await this.contentsManager.newUntitled({\n            path: PathExt.dirname(request.path),\n            type: request.data.mode === DIR_MODE ? 'directory' : 'file',\n            ext: PathExt.extname(request.path),\n        });\n        await this.contentsManager.rename(model.path, request.path);\n        return null;\n    }\n    async getattr(request) {\n        const model = await this.contentsManager.get(request.path);\n        // create a default date for drives that send incomplete information\n        // for nested foldes and files\n        const defaultDate = new Date(0).toISOString();\n        return {\n            dev: 1,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: 0,\n            size: model.size || 0,\n            blksize: BLOCK_SIZE,\n            blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),\n            atime: model.last_modified || defaultDate,\n            mtime: model.last_modified || defaultDate,\n            ctime: model.created || defaultDate,\n            timestamp: 0,\n        };\n    }\n    async get(request) {\n        const model = await this.contentsManager.get(request.path, { content: true });\n        let response;\n        if (model.type !== 'directory') {\n            response = {\n                content: model.format === 'json' ? JSON.stringify(model.content) : model.content,\n                format: model.format,\n            };\n        }\n        return response;\n    }\n    async put(request) {\n        await this.contentsManager.save(request.path, {\n            content: request.data.format === 'json'\n                ? JSON.parse(request.data.data)\n                : request.data.data,\n            type: 'file',\n            format: request.data.format,\n        });\n        return null;\n    }\n}\n//# sourceMappingURL=drivecontents.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DRIVE_API_PATH } from './drivefs';\nimport { DriveContentsProcessor } from './drivecontents';\n/** A broadcaster for the ServiceWorker */\nexport class BroadcastChannelWrapper {\n    constructor(options) {\n        this.isDisposed = false;\n        /** Handle a message received on the BroadcastChannel */\n        this._onMessage = async (event) => {\n            if (!this._channel) {\n                return;\n            }\n            const request = event.data;\n            const receiver = request === null || request === void 0 ? void 0 : request.receiver;\n            if (receiver !== 'broadcast.ts') {\n                // Message is not meant for us\n                return;\n            }\n            const response = await this._driveContentsProcessor.processDriveRequest(request);\n            this._channel.postMessage(response);\n        };\n        this._channel = null;\n        this._enabled = false;\n        this._contents = options.contents;\n        this._driveContentsProcessor = new DriveContentsProcessor({\n            contentsManager: this._contents,\n        });\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    enable() {\n        if (this._channel) {\n            console.warn('BroadcastChannel already created and enabled');\n            return;\n        }\n        this._channel = new BroadcastChannel(DRIVE_API_PATH);\n        this._channel.addEventListener('message', this._onMessage);\n        this._enabled = true;\n    }\n    disable() {\n        if (this._channel) {\n            this._channel.removeEventListener('message', this._onMessage);\n            this._channel = null;\n        }\n        this._enabled = false;\n    }\n    /** Clean up the broadcaster. */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.disable();\n        this.isDisposed = true;\n    }\n}\n//# sourceMappingURL=broadcast.js.map"],"names":["MIME","FILE","JSON","PLAIN_TEXT","OCTET_STREAM","TYPES","parse","PageConfig","getOption","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","length","hasFormat","fileFormat","IBroadcastChannelWrapper","Token","DEFAULT_STORAGE_NAME","DRIVE_NAME","encoder","TextEncoder","decoder","TextDecoder","BrowserStorageDrive","constructor","options","_a","this","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_isDisposed","_fileChanged","Signal","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_serverSettings","serverSettings","ServerConnection","makeSettings","_ready","PromiseDelegate","initialize","catch","console","warn","dispose","isDisposed","clearData","name","fileChanged","getDownloadUrl","path","Error","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","createInstance","description","storeName","newUntitled","_b","_c","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","writable","counter","Private","EMPTY_NB","encode","stringify","startsWith","indexOf","key","setItem","emit","oldValue","newValue","copy","toDir","removeSlash","base","replace","toPath","decodeURIComponent","folder","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","has","rename","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","URLExt","join","save","chunk","appendChunk","originalContent","lastChunk","contentBinaryString","_handleUploadChunk","decode","_binaryStringToBytes","btoa","slashed","toDelete","keys","filter","Promise","all","map","forgetPath","createCheckpoint","copies","Boolean","push","splice","id","listCheckpoints","normalizeCheckpoint","toString","restoreCheckpoint","checkpointID","parseInt","deleteCheckpoint","newContent","newContentBinaryString","atob","binaryString","bytes","Uint8Array","i","charCodeAt","includes","fileUrl","getBaseUrl","response","fetch","ok","headers","match","contentText","text","contentBuffer","arrayBuffer","contentBytes","reduce","apiURL","json","err","metadata","orig_nbformat","nbformat_minor","nbformat","cells","DIR_MODE","FILE_MODE","SEEK_CUR","SEEK_END","instanceOfStream","nodeOrStream","DRIVE_SEPARATOR","DRIVE_API_PATH","BLOCK_SIZE","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","open","stream","realPath","node","FS","isFile","mode","API","close","flags","parsedFlags","needsWrite","put","undefined","read","buffer","offset","position","Math","min","subarray","write","timestamp","now","oldData","llseek","whence","ErrnoError","ERRNO_CODES","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","value","ino","setattr","attr","entries","slice","lookup","parent","PATH","join2","result","createNode","mknod","dev","newDir","newName","oldNode","newDirNode","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","driveName","mountpoint","_driveName","_mountpoint","request","method","normalizePath","getmode","newPath","dirlist","serializedContent","binString","len","binary","byteLength","stats","atime","mtime","ctime","ServiceWorkerContentsAPI","baseUrl","super","_baseUrl","xhr","XMLHttpRequest","encodeURI","endpoint","send","e","error","status","responseText","DriveFS","createAPI","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","apply","DriveContentsProcessor","contentsManager","processDriveRequest","subcontent","delete","defaultDate","nlink","uid","gid","rdev","blksize","blocks","ceil","BroadcastChannelWrapper","_onMessage","async","event","_channel","receiver","_driveContentsProcessor","postMessage","_enabled","_contents","contents","enabled","enable","BroadcastChannel","addEventListener","disable","removeEventListener"],"sourceRoot":""}