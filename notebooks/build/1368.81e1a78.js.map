{"version":3,"file":"1368.81e1a78.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/node_modules/@codemirror/autocomplete/dist/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/node_modules/@lezer/markdown/dist/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/node_modules/@codemirror/lang-css/dist/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/node_modules/@codemirror/lang-html/dist/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { Annotation, StateEffect, EditorSelection, codePointAt, codePointSize, fromCodePoint, Facet, combineConfig, StateField, Prec, Text, MapMode, RangeValue, RangeSet, CharCategory } from '@codemirror/state';\nimport { Direction, logException, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sourcesin the editor, the extension will create\n    these for you.)\n    */\n    constructor(\n    /**\n    The editor state that the completion happens in.\n    */\n    state, \n    /**\n    The position at which the completion is happening.\n    */\n    pos, \n    /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */\n        this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */\n    tokenBefore(types) {\n        let token = syntaxTree(this.state).resolveInner(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n    get aborted() { return this.abortListeners == null; }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n    addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [validFor, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return source(context);\n            if (pos.type.isTop)\n                break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n            if (pos.type.isTop)\n                break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) { return state.selection.main.from; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\nconst pickedCompletion = /*@__PURE__*/Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\nfunction insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange(range => {\n        if (range != main && from != to &&\n            state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))\n            return { range };\n        return {\n            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: text },\n            range: EditorSelection.cursor(range.from + fromOff + text.length)\n        };\n    })), { userEvent: \"input.complete\" });\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/StateEffect.define();\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = codePointAt(pattern, p), size = codePointSize(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return true;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return this.ret(-100 /* NotFull */, []);\n        if (word.length < this.pattern.length)\n            return false;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = codePointAt(word, 0), firstSize = codePointSize(first);\n            let score = firstSize == word.length ? 0 : -100 /* NotFull */;\n            if (first == chars[0]) ;\n            else if (first == folded[0])\n                score += -200 /* CaseFold */;\n            else\n                return false;\n            return this.ret(score, [0, firstSize]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return this.ret(word.length == this.pattern.length ? 0 : -100 /* NotFull */, [0, this.pattern.length]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = codePointAt(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += codePointSize(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return false;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = codePointAt(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if (!i || type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) {\n                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))\n                    byWord[byWordTo++] = i;\n                else if (byWord.length)\n                    wordAdjacent = false;\n            }\n            prevType = type;\n            i += codePointSize(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return this.ret(-200 /* CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* NotFull */), [0, adjacentEnd]);\n        if (direct > -1)\n            return this.ret(-700 /* NotStart */ - word.length, [direct, direct + this.pattern.length]);\n        if (adjacentTo == len)\n            return this.ret(-200 /* CaseFold */ + -700 /* NotStart */ - word.length, [adjacentStart, adjacentEnd]);\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */ +\n                (wordAdjacent ? 0 : -1100 /* Gap */), byWord, word);\n        return chars.length == 2 ? false\n            : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n            if (i && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\n\nconst completionConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            activateOnTyping: true,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: () => \"\",\n            optionClass: () => \"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            compareCompletions: (a, b) => a.label.localeCompare(b.label),\n            interactionDelay: 75\n        }, {\n            defaultKeymap: (a, b) => a && b,\n            closeOnBlur: (a, b) => a && b,\n            icons: (a, b) => a && b,\n            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),\n            optionClass: (a, b) => c => joinClass(a(c), b(c)),\n            addToOptions: (a, b) => a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space) {\n    let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight))\n        left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))\n        left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Width */, left ? spaceLeft : spaceRight);\n    }\n    else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Width */, (rtl ? list.right : space.right - list.left) - 30 /* Margin */);\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion\n            offset = option.bottom - list.top;\n        }\n        else { // Above it\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    return {\n        style: `${side}: ${offset}px; max-width: ${maxWidth}px`,\n        class: \"cm-completionInfo-\" + (narrow ? (rtl ? \"left-narrow\" : \"right-narrow\") : left ? \"left\" : \"right\")\n    };\n}\n\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons)\n        content.push({\n            render(completion) {\n                let icon = document.createElement(\"div\");\n                icon.classList.add(\"cm-completionIcon\");\n                if (completion.type)\n                    icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n                icon.setAttribute(\"aria-hidden\", \"true\");\n                return icon;\n            },\n            position: 20\n        });\n    content.push({\n        render(completion, _s, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for (let j = 0; j < match.length;) {\n                let from = match[j++], to = match[j++];\n                if (from > off)\n                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length)\n                labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render(completion) {\n            if (!completion.detail)\n                return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected < 0)\n        selected = 0;\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion) {\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e) => {\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&\n                e.relatedTarget != view.contentDOM)\n                view.dispatch({ effects: closeCompletionEffect.of(null) });\n        });\n        this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        var _a, _b, _c;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            this.updateSel();\n            if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))\n                this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))\n                if (c)\n                    this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))\n                if (c)\n                    this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info)\n            this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfoReq);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info)\n                return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult)\n                return;\n            if (\"then\" in infoResult) {\n                infoResult.then(obj => {\n                    if (obj && this.view.state.field(this.stateField, false) == cState)\n                        this.addInfoPane(obj, completion);\n                }).catch(e => logException(this.view.state, e, \"completion info\"));\n            }\n            else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        }\n        else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            }\n            else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info)\n            return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||\n            selRect.bottom < Math.max(space.top, listRect.top) + 10)\n            return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style)\n                    this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            }\n            else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for (let i = range.from; i < range.to; i++) {\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    }\n                    else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls)\n                li.className = cls;\n            for (let source of this.optionContent) {\n                let node = source(completion, this.view.state, match);\n                if (node)\n                    li.appendChild(node);\n            }\n        }\n        if (range.from)\n            ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length)\n            ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy)\n                this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view) => new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option) => {\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections)\n                sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some(s => s.name == name))\n                sections.push(typeof section == \"string\" ? { name } : section);\n        }\n    };\n    for (let a of active)\n        if (a.hasResult()) {\n            let getMatch = a.result.getMatch;\n            if (a.result.filter === false) {\n                for (let option of a.result.options) {\n                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n                }\n            }\n            else {\n                let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));\n                for (let option of a.result.options)\n                    if (matcher.match(option.label)) {\n                        let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];\n                        addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));\n                    }\n            }\n        }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };\n        for (let s of sections.sort(cmp)) {\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options) {\n            let { section } = option.completion;\n            if (section)\n                option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = state.facet(completionConfig).compareCompletions;\n    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||\n            (prev.type != null && cur.type != null && prev.type != cur.type) ||\n            prev.apply != cur.apply || prev.boost != cur.boost)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some(a => a.state == 1 /* Pending */) ?\n                new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length; i++)\n                if (options[i].completion == selectedValue) {\n                    selected = i;\n                    break;\n                }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: completionTooltip(completionState, applyCompletion),\n            above: conf.aboveCursor,\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) ||\n                new ActiveSource(source, this.active.some(a => a.state != 0 /* Inactive */) ? 1 /* Pending */ : 0 /* Inactive */);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged)\n            open = open.map(tr.changes);\n        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active))\n            open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some(a => a.state == 1 /* Pending */))\n            open = null;\n        if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */) : a);\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : null; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1)\n        result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1) {\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event)\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* Pending */);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to) {\n        super(source, 2 /* Result */, explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        var _a;\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||\n            pos > to ||\n            type == \"delete\" && cur(tr.startState) == this.from)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */);\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\n        if (checkValid(this.result.validFor, tr.state, from, to))\n            return new ActiveResult(this.source, explicitPos, this.result, from, to);\n        if (this.result.update &&\n            (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))\n            return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* Pending */, explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this :\n            new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor)\n        return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.map(mapping)); }\n});\nconst setSelectedEffect = /*@__PURE__*/StateEffect.define();\nconst completionState = /*@__PURE__*/StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        showTooltip.from(f, val => val.tooltip),\n        EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find(a => a.source == option.source);\n    if (!(result instanceof ActiveResult))\n        return false;\n    if (typeof apply == \"string\")\n        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));\n    else\n        apply(view, option.completion, result.from, result.to);\n    return true;\n}\n\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled ||\n            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = getTooltip(view, cState.open.tooltip)))\n            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /\n                tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||\n        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n        return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context) {\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        logException(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.active.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (getUserEvent(tr) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.active.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            logException(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* Inactive */);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        blur(event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && getTooltip(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget))\n                    this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            }\n        },\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\n            }\n            this.composing = 0 /* None */;\n        }\n    }\n});\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\",\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\",\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\",\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\",\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Width */}px`,\n        boxSizing: \"border-box\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": { right: `${30 /* Margin */}px` },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": { left: `${30 /* Margin */}px` },\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": { content: \"'\\uFE0E'\" } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name });\n                    found = i;\n                    for (let pos of positions)\n                        if (pos.field >= found)\n                            pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            for (let esc; esc = /\\\\([{}])/.exec(line);) {\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n                for (let pos of positions)\n                    if (pos.line == lines.length && pos.from > esc.index) {\n                        pos.from--;\n                        pos.to--;\n                    }\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/Decoration.widget({ widget: /*@__PURE__*/new class extends WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = /*@__PURE__*/Decoration.mark({ class: \"cm-snippetField\" });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges) {\n            let mapped = r.map(changes);\n            if (!mapped)\n                return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = /*@__PURE__*/StateEffect.define();\nconst snippetState = /*@__PURE__*/StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: { from, to, insert: Text.of(text) },\n            scrollIntoView: true,\n            annotations: completion ? pickedCompletion.of(completion) : undefined\n        };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [setActive.of(active)];\n            if (editor.state.field(snippetState, false) === undefined)\n                effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/\nfunction hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some(r => r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/\nfunction hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\nconst snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n    mousedown(event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\n            return false;\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active)\n            return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n        });\n        return true;\n    }\n});\n\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    }\n    catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while (m = wordRE.exec(value)) {\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({ type: \"text\", label: m[0] });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* MaxList */)\n                    return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* MinCacheLen */;\n    let cached = big && cache.get(doc);\n    if (cached)\n        return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children) {\n            if (ch.length >= 1000 /* MinCacheLen */) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            }\n            else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    }\n    else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* MaxList */)\n        cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n    if (!token && !context.explicit)\n        return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* Range */, from);\n    return { from, options, validFor: mapRE(re, s => \"^\" + s) };\n};\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/new class extends RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/StateField.define({\n    create() { return RangeSet.empty; },\n    update(value, tr) {\n        if (tr.selection) {\n            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\n                value = RangeSet.empty;\n        }\n        value = value.map(tr.changes);\n        for (let effect of tr.effects)\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\nfunction closeBrackets() {\n    return [inputHandler, bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, insert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)\n        return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\nconst deleteBracketPair = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: EditorSelection.cursor(range.head - token.length) };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete.backward\" }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert bracketsthe\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\nfunction insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing(codePointAt(tok, 0));\n        if (bracket == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return { changes: { from: range.head, to: range.head + close.length, insert: close },\n                range: EditorSelection.cursor(range.head + close.length) };\n        return dont = { range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return { changes: { from: pos, to: pos + content.length, insert: content },\n                    range: EditorSelection.cursor(pos + content.length) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&\n            nodeStart(state, start)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = syntaxTree(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = syntaxTree(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);\n    for (let i = 0; i < 5; i++) {\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)\n                    return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent)\n            break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)\n        return pos;\n    for (let prefix of prefixes) {\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)\n            return start;\n    }\n    return -1;\n}\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [\n    { key: \"Ctrl-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/new WeakMap;\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled)\n        return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions)\n        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\nfunction selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\nfunction selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\nfunction setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeBrackets, closeBracketsKeymap, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, deleteBracketPair, hasNextSnippetField, hasPrevSnippetField, ifIn, ifNotIn, insertBracket, insertCompletionText, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, selectedCompletionIndex, setSelectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };\n","import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// For reused nodes on gaps, we can't directly put the original\n        /// node into the tree, since that may be bitter than its parent.\n        /// When this happens, we create a dummy tree that is replaced by\n        /// the proper node in `injectGaps` @internal\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0) | (canClose ? 2 /* Mark.Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0) | (close ? 2 /* Mark.Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { parser } from '@lezer/css';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\nlet _properties = null;\nfunction properties() {\n    if (!_properties && typeof document == \"object\" && document.body) {\n        let { style } = document.body, names = [], seen = new Set;\n        for (let prop in style)\n            if (prop != \"cssText\" && prop != \"cssFloat\") {\n                if (typeof style[prop] == \"string\") {\n                    if (/[A-Z]/.test(prop))\n                        prop = prop.replace(/[A-Z]/g, ch => \"-\" + ch.toLowerCase());\n                    if (!seen.has(prop)) {\n                        names.push(prop);\n                        seen.add(prop);\n                    }\n                }\n            }\n        _properties = names.sort().map(name => ({ type: \"property\", label: name }));\n    }\n    return _properties || [];\n}\nconst pseudoClasses = /*@__PURE__*/[\n    \"active\", \"after\", \"any-link\", \"autofill\", \"backdrop\", \"before\",\n    \"checked\", \"cue\", \"default\", \"defined\", \"disabled\", \"empty\",\n    \"enabled\", \"file-selector-button\", \"first\", \"first-child\",\n    \"first-letter\", \"first-line\", \"first-of-type\", \"focus\",\n    \"focus-visible\", \"focus-within\", \"fullscreen\", \"has\", \"host\",\n    \"host-context\", \"hover\", \"in-range\", \"indeterminate\", \"invalid\",\n    \"is\", \"lang\", \"last-child\", \"last-of-type\", \"left\", \"link\", \"marker\",\n    \"modal\", \"not\", \"nth-child\", \"nth-last-child\", \"nth-last-of-type\",\n    \"nth-of-type\", \"only-child\", \"only-of-type\", \"optional\", \"out-of-range\",\n    \"part\", \"placeholder\", \"placeholder-shown\", \"read-only\", \"read-write\",\n    \"required\", \"right\", \"root\", \"scope\", \"selection\", \"slotted\", \"target\",\n    \"target-text\", \"valid\", \"visited\", \"where\"\n].map(name => ({ type: \"class\", label: name }));\nconst values = /*@__PURE__*/[\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"after-white-space\",\n    \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\", \"always\",\n    \"antialiased\", \"appworkspace\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\",\n    \"avoid-page\", \"avoid-region\", \"axis-pan\", \"background\", \"backwards\", \"baseline\", \"below\",\n    \"bidi-override\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"capitalize\",\n    \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\", \"cell\", \"center\", \"checkbox\", \"circle\",\n    \"cjk-decimal\", \"clear\", \"clip\", \"close-quote\", \"col-resize\", \"collapse\", \"color\", \"color-burn\",\n    \"color-dodge\", \"column\", \"column-reverse\", \"compact\", \"condensed\", \"contain\", \"content\",\n    \"contents\", \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\",\n    \"crop\", \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\", \"destination-in\",\n    \"destination-out\", \"destination-over\", \"difference\", \"disc\", \"discard\", \"disclosure-closed\",\n    \"disclosure-open\", \"document\", \"dot-dash\", \"dot-dot-dash\", \"dotted\", \"double\", \"down\", \"e-resize\",\n    \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\", \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\",\n    \"ethiopic-abegede-gez\", \"ethiopic-halehame-aa-er\", \"ethiopic-halehame-gez\", \"ew-resize\", \"exclusion\",\n    \"expanded\", \"extends\", \"extra-condensed\", \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fill-box\",\n    \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\", \"forwards\", \"from\",\n    \"geometricPrecision\", \"graytext\", \"grid\", \"groove\", \"hand\", \"hard-light\", \"help\", \"hidden\", \"hide\",\n    \"higher\", \"highlight\", \"highlighttext\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\", \"infobackground\", \"infotext\",\n    \"inherit\", \"initial\", \"inline\", \"inline-axis\", \"inline-block\", \"inline-flex\", \"inline-grid\",\n    \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\", \"italic\", \"justify\", \"keep-all\",\n    \"landscape\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\", \"line-through\", \"linear\",\n    \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\", \"local\", \"logical\", \"loud\", \"lower\",\n    \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\", \"lowercase\", \"ltr\", \"luminosity\", \"manipulation\",\n    \"match\", \"matrix\", \"matrix3d\", \"medium\", \"menu\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"monospace\", \"move\", \"multiple\", \"multiple_mask_images\", \"multiply\", \"n-resize\", \"narrower\",\n    \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\", \"no-open-quote\", \"no-repeat\", \"none\",\n    \"normal\", \"not-allowed\", \"nowrap\", \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\",\n    \"oblique\", \"opacity\", \"open-quote\", \"optimizeLegibility\", \"optimizeSpeed\", \"outset\", \"outside\",\n    \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\", \"painted\", \"page\", \"paused\",\n    \"perspective\", \"pinch-zoom\", \"plus-darker\", \"plus-lighter\", \"pointer\", \"polygon\", \"portrait\",\n    \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\", \"progress\", \"push-button\", \"radial-gradient\", \"radio\",\n    \"read-only\", \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\", \"relative\", \"repeat\",\n    \"repeating-linear-gradient\", \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\", \"rotateZ\", \"round\",\n    \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\", \"s-resize\", \"sans-serif\", \"saturation\",\n    \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\", \"scroll\", \"scrollbar\", \"scroll-position\",\n    \"se-resize\", \"self-start\", \"self-end\", \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\",\n    \"single\", \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\", \"small\", \"small-caps\",\n    \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"source-atop\", \"source-in\", \"source-out\",\n    \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\", \"start\",\n    \"static\", \"status-bar\", \"stretch\", \"stroke\", \"stroke-box\", \"sub\", \"subpixel-antialiased\", \"svg_masks\",\n    \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\", \"table-caption\", \"table-cell\",\n    \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row\",\n    \"table-row-group\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thick\", \"thin\",\n    \"threeddarkshadow\", \"threedface\", \"threedhighlight\", \"threedlightshadow\", \"threedshadow\", \"to\", \"top\",\n    \"transform\", \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\", \"transparent\",\n    \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unidirectional-pan\", \"unset\", \"up\", \"upper-latin\",\n    \"uppercase\", \"url\", \"var\", \"vertical\", \"vertical-text\", \"view-box\", \"visible\", \"visibleFill\",\n    \"visiblePainted\", \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\", \"window\", \"windowframe\",\n    \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\", \"xx-large\", \"xx-small\"\n].map(name => ({ type: \"keyword\", label: name })).concat(/*@__PURE__*/[\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n].map(name => ({ type: \"constant\", label: name })));\nconst tags = /*@__PURE__*/[\n    \"a\", \"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\", \"blockquote\", \"body\",\n    \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"dd\", \"del\",\n    \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"figcaption\", \"figure\", \"footer\",\n    \"form\", \"header\", \"hgroup\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"html\", \"i\", \"iframe\",\n    \"img\", \"input\", \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"meter\", \"nav\", \"ol\", \"output\",\n    \"p\", \"pre\", \"ruby\", \"section\", \"select\", \"small\", \"source\", \"span\", \"strong\", \"sub\", \"summary\",\n    \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"tr\", \"u\", \"ul\"\n].map(name => ({ type: \"type\", label: name }));\nconst identifier = /^(\\w[\\w-]*|-\\w[\\w-]*|)$/, variable = /^-(-[\\w-]*)?$/;\nfunction isVarArg(node, doc) {\n    var _a;\n    if (node.name == \"(\" || node.type.isError)\n        node = node.parent || node;\n    if (node.name != \"ArgList\")\n        return false;\n    let callee = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstChild;\n    if ((callee === null || callee === void 0 ? void 0 : callee.name) != \"Callee\")\n        return false;\n    return doc.sliceString(callee.from, callee.to) == \"var\";\n}\nconst VariablesByNode = /*@__PURE__*/new NodeWeakMap();\nconst declSelector = [\"Declaration\"];\nfunction astTop(node) {\n    for (let cur = node;;) {\n        if (cur.type.isTop)\n            return cur;\n        if (!(cur = cur.parent))\n            return node;\n    }\n}\nfunction variableNames(doc, node, isVariable) {\n    if (node.to - node.from > 4096) {\n        let known = VariablesByNode.get(node);\n        if (known)\n            return known;\n        let result = [], seen = new Set, cursor = node.cursor(IterMode.IncludeAnonymous);\n        if (cursor.firstChild())\n            do {\n                for (let option of variableNames(doc, cursor.node, isVariable))\n                    if (!seen.has(option.label)) {\n                        seen.add(option.label);\n                        result.push(option);\n                    }\n            } while (cursor.nextSibling());\n        VariablesByNode.set(node, result);\n        return result;\n    }\n    else {\n        let result = [], seen = new Set;\n        node.cursor().iterate(node => {\n            var _a;\n            if (isVariable(node) && node.matchContext(declSelector) && ((_a = node.node.nextSibling) === null || _a === void 0 ? void 0 : _a.name) == \":\") {\n                let name = doc.sliceString(node.from, node.to);\n                if (!seen.has(name)) {\n                    seen.add(name);\n                    result.push({ label: name, type: \"variable\" });\n                }\n            }\n        });\n        return result;\n    }\n}\n/**\nCreate a completion source for a CSS dialect, providing a\npredicate for determining what kind of syntax node can act as a\ncompletable variable. This is used by language modes like Sass and\nLess to reuse this package's completion logic.\n*/\nconst defineCSSCompletionSource = (isVariable) => context => {\n    let { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);\n    let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == \"-\";\n    if (node.name == \"PropertyName\" ||\n        (isDash || node.name == \"TagName\") && /^(Block|Styles)$/.test(node.resolve(node.to).name))\n        return { from: node.from, options: properties(), validFor: identifier };\n    if (node.name == \"ValueName\")\n        return { from: node.from, options: values, validFor: identifier };\n    if (node.name == \"PseudoClassName\")\n        return { from: node.from, options: pseudoClasses, validFor: identifier };\n    if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc))\n        return { from: isVariable(node) || isDash ? node.from : pos,\n            options: variableNames(state.doc, astTop(node), isVariable),\n            validFor: variable };\n    if (node.name == \"TagName\") {\n        for (let { parent } = node; parent; parent = parent.parent)\n            if (parent.name == \"Block\")\n                return { from: node.from, options: properties(), validFor: identifier };\n        return { from: node.from, options: tags, validFor: identifier };\n    }\n    if (!context.explicit)\n        return null;\n    let above = node.resolve(pos), before = above.childBefore(pos);\n    if (before && before.name == \":\" && above.name == \"PseudoClassSelector\")\n        return { from: pos, options: pseudoClasses, validFor: identifier };\n    if (before && before.name == \":\" && above.name == \"Declaration\" || above.name == \"ArgList\")\n        return { from: pos, options: values, validFor: identifier };\n    if (above.name == \"Block\" || above.name == \"Styles\")\n        return { from: pos, options: properties(), validFor: identifier };\n    return null;\n};\n/**\nCSS property, variable, and value keyword completion source.\n*/\nconst cssCompletionSource = /*@__PURE__*/defineCSSCompletionSource(n => n.name == \"VariableName\");\n\n/**\nA language provider based on the [Lezer CSS\nparser](https://github.com/lezer-parser/css), extended with\nhighlighting and indentation information.\n*/\nconst cssLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"css\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Declaration: /*@__PURE__*/continuedIndent()\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Block: foldInside\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*\\}$/,\n        wordChars: \"-\"\n    }\n});\n/**\nLanguage support for CSS.\n*/\nfunction css() {\n    return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));\n}\n\nexport { css, cssCompletionSource, cssLanguage, defineCSSCompletionSource };\n","import { parser, configureNesting } from '@lezer/html';\nimport { cssLanguage, css } from '@codemirror/lang-css';\nimport { typescriptLanguage, jsxLanguage, tsxLanguage, javascriptLanguage, javascript } from '@codemirror/lang-javascript';\nimport { EditorView } from '@codemirror/view';\nimport { EditorSelection } from '@codemirror/state';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\n\nconst Targets = [\"_blank\", \"_self\", \"_top\", \"_parent\"];\nconst Charsets = [\"ascii\", \"utf-8\", \"utf-16\", \"latin1\", \"latin1\"];\nconst Methods = [\"get\", \"post\", \"put\", \"delete\"];\nconst Encs = [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"];\nconst Bool = [\"true\", \"false\"];\nconst S = {}; // Empty tag spec\nconst Tags = {\n    a: {\n        attrs: {\n            href: null, ping: null, type: null,\n            media: null,\n            target: Targets,\n            hreflang: null\n        }\n    },\n    abbr: S,\n    address: S,\n    area: {\n        attrs: {\n            alt: null, coords: null, href: null, target: null, ping: null,\n            media: null, hreflang: null, type: null,\n            shape: [\"default\", \"rect\", \"circle\", \"poly\"]\n        }\n    },\n    article: S,\n    aside: S,\n    audio: {\n        attrs: {\n            src: null, mediagroup: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"],\n            preload: [\"none\", \"metadata\", \"auto\"],\n            autoplay: [\"autoplay\"],\n            loop: [\"loop\"],\n            controls: [\"controls\"]\n        }\n    },\n    b: S,\n    base: { attrs: { href: null, target: Targets } },\n    bdi: S,\n    bdo: S,\n    blockquote: { attrs: { cite: null } },\n    body: S,\n    br: S,\n    button: {\n        attrs: {\n            form: null, formaction: null, name: null, value: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"autofocus\"],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\"novalidate\"],\n            formtarget: Targets,\n            type: [\"submit\", \"reset\", \"button\"]\n        }\n    },\n    canvas: { attrs: { width: null, height: null } },\n    caption: S,\n    center: S,\n    cite: S,\n    code: S,\n    col: { attrs: { span: null } },\n    colgroup: { attrs: { span: null } },\n    command: {\n        attrs: {\n            type: [\"command\", \"checkbox\", \"radio\"],\n            label: null, icon: null, radiogroup: null, command: null, title: null,\n            disabled: [\"disabled\"],\n            checked: [\"checked\"]\n        }\n    },\n    data: { attrs: { value: null } },\n    datagrid: { attrs: { disabled: [\"disabled\"], multiple: [\"multiple\"] } },\n    datalist: { attrs: { data: null } },\n    dd: S,\n    del: { attrs: { cite: null, datetime: null } },\n    details: { attrs: { open: [\"open\"] } },\n    dfn: S,\n    div: S,\n    dl: S,\n    dt: S,\n    em: S,\n    embed: { attrs: { src: null, type: null, width: null, height: null } },\n    eventsource: { attrs: { src: null } },\n    fieldset: { attrs: { disabled: [\"disabled\"], form: null, name: null } },\n    figcaption: S,\n    figure: S,\n    footer: S,\n    form: {\n        attrs: {\n            action: null, name: null,\n            \"accept-charset\": Charsets,\n            autocomplete: [\"on\", \"off\"],\n            enctype: Encs,\n            method: Methods,\n            novalidate: [\"novalidate\"],\n            target: Targets\n        }\n    },\n    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,\n    head: {\n        children: [\"title\", \"base\", \"link\", \"style\", \"meta\", \"script\", \"noscript\", \"command\"]\n    },\n    header: S,\n    hgroup: S,\n    hr: S,\n    html: {\n        attrs: { manifest: null }\n    },\n    i: S,\n    iframe: {\n        attrs: {\n            src: null, srcdoc: null, name: null, width: null, height: null,\n            sandbox: [\"allow-top-navigation\", \"allow-same-origin\", \"allow-forms\", \"allow-scripts\"],\n            seamless: [\"seamless\"]\n        }\n    },\n    img: {\n        attrs: {\n            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"]\n        }\n    },\n    input: {\n        attrs: {\n            alt: null, dirname: null, form: null, formaction: null,\n            height: null, list: null, max: null, maxlength: null, min: null,\n            name: null, pattern: null, placeholder: null, size: null, src: null,\n            step: null, value: null, width: null,\n            accept: [\"audio/*\", \"video/*\", \"image/*\"],\n            autocomplete: [\"on\", \"off\"],\n            autofocus: [\"autofocus\"],\n            checked: [\"checked\"],\n            disabled: [\"disabled\"],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\"novalidate\"],\n            formtarget: Targets,\n            multiple: [\"multiple\"],\n            readonly: [\"readonly\"],\n            required: [\"required\"],\n            type: [\"hidden\", \"text\", \"search\", \"tel\", \"url\", \"email\", \"password\", \"datetime\", \"date\", \"month\",\n                \"week\", \"time\", \"datetime-local\", \"number\", \"range\", \"color\", \"checkbox\", \"radio\",\n                \"file\", \"submit\", \"image\", \"reset\", \"button\"]\n        }\n    },\n    ins: { attrs: { cite: null, datetime: null } },\n    kbd: S,\n    keygen: {\n        attrs: {\n            challenge: null, form: null, name: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            keytype: [\"RSA\"]\n        }\n    },\n    label: { attrs: { for: null, form: null } },\n    legend: S,\n    li: { attrs: { value: null } },\n    link: {\n        attrs: {\n            href: null, type: null,\n            hreflang: null,\n            media: null,\n            sizes: [\"all\", \"16x16\", \"16x16 32x32\", \"16x16 32x32 64x64\"]\n        }\n    },\n    map: { attrs: { name: null } },\n    mark: S,\n    menu: { attrs: { label: null, type: [\"list\", \"context\", \"toolbar\"] } },\n    meta: {\n        attrs: {\n            content: null,\n            charset: Charsets,\n            name: [\"viewport\", \"application-name\", \"author\", \"description\", \"generator\", \"keywords\"],\n            \"http-equiv\": [\"content-language\", \"content-type\", \"default-style\", \"refresh\"]\n        }\n    },\n    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },\n    nav: S,\n    noscript: S,\n    object: {\n        attrs: {\n            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,\n            typemustmatch: [\"typemustmatch\"]\n        }\n    },\n    ol: { attrs: { reversed: [\"reversed\"], start: null, type: [\"1\", \"a\", \"A\", \"i\", \"I\"] },\n        children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"] },\n    optgroup: { attrs: { disabled: [\"disabled\"], label: null } },\n    option: { attrs: { disabled: [\"disabled\"], label: null, selected: [\"selected\"], value: null } },\n    output: { attrs: { for: null, form: null, name: null } },\n    p: S,\n    param: { attrs: { name: null, value: null } },\n    pre: S,\n    progress: { attrs: { value: null, max: null } },\n    q: { attrs: { cite: null } },\n    rp: S,\n    rt: S,\n    ruby: S,\n    samp: S,\n    script: {\n        attrs: {\n            type: [\"text/javascript\"],\n            src: null,\n            async: [\"async\"],\n            defer: [\"defer\"],\n            charset: Charsets\n        }\n    },\n    section: S,\n    select: {\n        attrs: {\n            form: null, name: null, size: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            multiple: [\"multiple\"]\n        }\n    },\n    slot: { attrs: { name: null } },\n    small: S,\n    source: { attrs: { src: null, type: null, media: null } },\n    span: S,\n    strong: S,\n    style: {\n        attrs: {\n            type: [\"text/css\"],\n            media: null,\n            scoped: null\n        }\n    },\n    sub: S,\n    summary: S,\n    sup: S,\n    table: S,\n    tbody: S,\n    td: { attrs: { colspan: null, rowspan: null, headers: null } },\n    template: S,\n    textarea: {\n        attrs: {\n            dirname: null, form: null, maxlength: null, name: null, placeholder: null,\n            rows: null, cols: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            readonly: [\"readonly\"],\n            required: [\"required\"],\n            wrap: [\"soft\", \"hard\"]\n        }\n    },\n    tfoot: S,\n    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: [\"row\", \"col\", \"rowgroup\", \"colgroup\"] } },\n    thead: S,\n    time: { attrs: { datetime: null } },\n    title: S,\n    tr: S,\n    track: {\n        attrs: {\n            src: null, label: null, default: null,\n            kind: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"],\n            srclang: null\n        }\n    },\n    ul: { children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"] },\n    var: S,\n    video: {\n        attrs: {\n            src: null, poster: null, width: null, height: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"],\n            preload: [\"auto\", \"metadata\", \"none\"],\n            autoplay: [\"autoplay\"],\n            mediagroup: [\"movie\"],\n            muted: [\"muted\"],\n            controls: [\"controls\"]\n        }\n    },\n    wbr: S\n};\nconst GlobalAttrs = {\n    accesskey: null,\n    class: null,\n    contenteditable: Bool,\n    contextmenu: null,\n    dir: [\"ltr\", \"rtl\", \"auto\"],\n    draggable: [\"true\", \"false\", \"auto\"],\n    dropzone: [\"copy\", \"move\", \"link\", \"string:\", \"file:\"],\n    hidden: [\"hidden\"],\n    id: null,\n    inert: [\"inert\"],\n    itemid: null,\n    itemprop: null,\n    itemref: null,\n    itemscope: [\"itemscope\"],\n    itemtype: null,\n    lang: [\"ar\", \"bn\", \"de\", \"en-GB\", \"en-US\", \"es\", \"fr\", \"hi\", \"id\", \"ja\", \"pa\", \"pt\", \"ru\", \"tr\", \"zh\"],\n    spellcheck: Bool,\n    autocorrect: Bool,\n    autocapitalize: Bool,\n    style: null,\n    tabindex: null,\n    title: null,\n    translate: [\"yes\", \"no\"],\n    rel: [\"stylesheet\", \"alternate\", \"author\", \"bookmark\", \"help\", \"license\", \"next\", \"nofollow\", \"noreferrer\", \"prefetch\", \"prev\", \"search\", \"tag\"],\n    role: /*@__PURE__*/\"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer\".split(\" \"),\n    \"aria-activedescendant\": null,\n    \"aria-atomic\": Bool,\n    \"aria-autocomplete\": [\"inline\", \"list\", \"both\", \"none\"],\n    \"aria-busy\": Bool,\n    \"aria-checked\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n    \"aria-controls\": null,\n    \"aria-describedby\": null,\n    \"aria-disabled\": Bool,\n    \"aria-dropeffect\": null,\n    \"aria-expanded\": [\"true\", \"false\", \"undefined\"],\n    \"aria-flowto\": null,\n    \"aria-grabbed\": [\"true\", \"false\", \"undefined\"],\n    \"aria-haspopup\": Bool,\n    \"aria-hidden\": Bool,\n    \"aria-invalid\": [\"true\", \"false\", \"grammar\", \"spelling\"],\n    \"aria-label\": null,\n    \"aria-labelledby\": null,\n    \"aria-level\": null,\n    \"aria-live\": [\"off\", \"polite\", \"assertive\"],\n    \"aria-multiline\": Bool,\n    \"aria-multiselectable\": Bool,\n    \"aria-owns\": null,\n    \"aria-posinset\": null,\n    \"aria-pressed\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n    \"aria-readonly\": Bool,\n    \"aria-relevant\": null,\n    \"aria-required\": Bool,\n    \"aria-selected\": [\"true\", \"false\", \"undefined\"],\n    \"aria-setsize\": null,\n    \"aria-sort\": [\"ascending\", \"descending\", \"none\", \"other\"],\n    \"aria-valuemax\": null,\n    \"aria-valuemin\": null,\n    \"aria-valuenow\": null,\n    \"aria-valuetext\": null\n};\nconst eventAttributes = /*@__PURE__*/(\"beforeunload copy cut dragstart dragover dragleave dragenter dragend \" +\n    \"drag paste focus blur change click load mousedown mouseenter mouseleave \" +\n    \"mouseup keydown keyup resize scroll unload\").split(\" \").map(n => \"on\" + n);\nfor (let a of eventAttributes)\n    GlobalAttrs[a] = null;\nclass Schema {\n    constructor(extraTags, extraAttrs) {\n        this.tags = Object.assign(Object.assign({}, Tags), extraTags);\n        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);\n        this.allTags = Object.keys(this.tags);\n        this.globalAttrNames = Object.keys(this.globalAttrs);\n    }\n}\nSchema.default = /*@__PURE__*/new Schema;\nfunction elementName(doc, tree, max = doc.length) {\n    if (!tree)\n        return \"\";\n    let tag = tree.firstChild;\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : \"\";\n}\nfunction findParentElement(tree, skip = false) {\n    for (; tree; tree = tree.parent)\n        if (tree.name == \"Element\") {\n            if (skip)\n                skip = false;\n            else\n                return tree;\n        }\n    return null;\n}\nfunction allowedChildren(doc, tree, schema) {\n    let parentInfo = schema.tags[elementName(doc, findParentElement(tree))];\n    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;\n}\nfunction openTags(doc, tree) {\n    let open = [];\n    for (let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {\n        let tagName = elementName(doc, parent);\n        if (tagName && parent.lastChild.name == \"CloseTag\")\n            break;\n        if (tagName && open.indexOf(tagName) < 0 && (tree.name == \"EndTag\" || tree.from >= parent.firstChild.to))\n            open.push(tagName);\n    }\n    return open;\n}\nconst identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction completeTag(state, schema, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    let parent = findParentElement(tree, true);\n    return { from, to,\n        options: allowedChildren(state.doc, parent, schema).map(tagName => ({ label: tagName, type: \"type\" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: \"/\" + tag, apply: \"/\" + tag + end,\n            type: \"type\", boost: 99 - i }))),\n        validFor: /^\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/ };\n}\nfunction completeCloseTag(state, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    return { from, to,\n        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: \"type\", boost: 99 - i })),\n        validFor: identifier };\n}\nfunction completeStartTag(state, schema, tree, pos) {\n    let options = [], level = 0;\n    for (let tagName of allowedChildren(state.doc, tree, schema))\n        options.push({ label: \"<\" + tagName, type: \"type\" });\n    for (let open of openTags(state.doc, tree))\n        options.push({ label: \"</\" + open + \">\", type: \"type\", boost: 99 - level++ });\n    return { from: pos, to: pos, options, validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/ };\n}\nfunction completeAttrName(state, schema, tree, from, to) {\n    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];\n    let names = info && info.globalAttrs === false ? localAttrs\n        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;\n    return { from, to,\n        options: names.map(attrName => ({ label: attrName, type: \"property\" })),\n        validFor: identifier };\n}\nfunction completeAttrValue(state, schema, tree, from, to) {\n    var _a;\n    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild(\"AttributeName\");\n    let options = [], token = undefined;\n    if (nameNode) {\n        let attrName = state.sliceDoc(nameNode.from, nameNode.to);\n        let attrs = schema.globalAttrs[attrName];\n        if (!attrs) {\n            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];\n        }\n        if (attrs) {\n            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '\"', quoteEnd = '\"';\n            if (/^['\"]/.test(base)) {\n                token = base[0] == '\"' ? /^[^\"]*$/ : /^[^']*$/;\n                quoteStart = \"\";\n                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? \"\" : base[0];\n                base = base.slice(1);\n                from++;\n            }\n            else {\n                token = /^[^\\s<>='\"]*$/;\n            }\n            for (let value of attrs)\n                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: \"constant\" });\n        }\n    }\n    return { from, to, options, validFor: token };\n}\nfunction htmlCompletionFor(schema, context) {\n    let { state, pos } = context, tree = syntaxTree(state).resolveInner(pos, -1), around = tree.resolve(pos);\n    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {\n        let last = before.lastChild;\n        if (!last || !last.type.isError || last.from < last.to)\n            break;\n        around = tree = before;\n        scan = last.from;\n    }\n    if (tree.name == \"TagName\") {\n        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)\n            : completeTag(state, schema, tree, tree.from, pos);\n    }\n    else if (tree.name == \"StartTag\") {\n        return completeTag(state, schema, tree, pos, pos);\n    }\n    else if (tree.name == \"StartCloseTag\" || tree.name == \"IncompleteCloseTag\") {\n        return completeCloseTag(state, tree, pos, pos);\n    }\n    else if (context.explicit && (tree.name == \"OpenTag\" || tree.name == \"SelfClosingTag\") || tree.name == \"AttributeName\") {\n        return completeAttrName(state, schema, tree, tree.name == \"AttributeName\" ? tree.from : pos, pos);\n    }\n    else if (tree.name == \"Is\" || tree.name == \"AttributeValue\" || tree.name == \"UnquotedAttributeValue\") {\n        return completeAttrValue(state, schema, tree, tree.name == \"Is\" ? pos : tree.from, pos);\n    }\n    else if (context.explicit && (around.name == \"Element\" || around.name == \"Text\" || around.name == \"Document\")) {\n        return completeStartTag(state, schema, tree, pos);\n    }\n    else {\n        return null;\n    }\n}\n/**\nHTML tag completion. Opens and closes tags and attributes in a\ncontext-aware way.\n*/\nfunction htmlCompletionSource(context) {\n    return htmlCompletionFor(Schema.default, context);\n}\n/**\nCreate a completion source for HTML extended with additional tags\nor attributes.\n*/\nfunction htmlCompletionSourceWith(config) {\n    let { extraTags, extraGlobalAttributes: extraAttrs } = config;\n    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;\n    return (context) => htmlCompletionFor(schema, context);\n}\n\nconst defaultNesting = [\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/typescript\" || attrs.lang == \"ts\",\n        parser: typescriptLanguage.parser },\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/babel\" || attrs.type == \"text/jsx\",\n        parser: jsxLanguage.parser },\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/typescript-jsx\",\n        parser: tsxLanguage.parser },\n    { tag: \"script\",\n        attrs(attrs) {\n            return !attrs.type || /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);\n        },\n        parser: javascriptLanguage.parser },\n    { tag: \"style\",\n        attrs(attrs) {\n            return (!attrs.lang || attrs.lang == \"css\") && (!attrs.type || /^(text\\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));\n        },\n        parser: cssLanguage.parser }\n];\nconst defaultAttrs = /*@__PURE__*/[\n    { name: \"style\",\n        parser: /*@__PURE__*/cssLanguage.parser.configure({ top: \"Styles\" }) }\n].concat(/*@__PURE__*/eventAttributes.map(name => ({ name, parser: javascriptLanguage.parser })));\n/**\nA language provider based on the [Lezer HTML\nparser](https://github.com/lezer-parser/html), extended with the\nJavaScript and CSS parsers to parse the content of `<script>` and\n`<style>` tags.\n*/\nconst htmlPlain = /*@__PURE__*/LRLanguage.define({\n    name: \"html\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let after = /^(\\s*)(<\\/)?/.exec(context.textAfter);\n                    if (context.node.to <= context.pos + after[0].length)\n                        return context.continue();\n                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                },\n                Document(context) {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length < context.node.to)\n                        return context.continue();\n                    let endElt = null, close;\n                    for (let cur = context.node;;) {\n                        let last = cur.lastChild;\n                        if (!last || last.name != \"Element\" || last.to != cur.to)\n                            break;\n                        endElt = cur = last;\n                    }\n                    if (endElt && !((close = endElt.lastChild) && (close.name == \"CloseTag\" || close.name == \"SelfClosingTag\")))\n                        return context.lineIndent(endElt.from) + context.unit;\n                    return null;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(node) {\n                    let first = node.firstChild, last = node.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : node.to };\n                }\n            }),\n            /*@__PURE__*/bracketMatchingHandle.add({\n                \"OpenTag CloseTag\": node => node.getChild(\"TagName\")\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/\\w+\\W$/,\n        wordChars: \"-._\"\n    }\n});\n/**\nA language provider based on the [Lezer HTML\nparser](https://github.com/lezer-parser/html), extended with the\nJavaScript and CSS parsers to parse the content of `<script>` and\n`<style>` tags.\n*/\nconst htmlLanguage = /*@__PURE__*/htmlPlain.configure({\n    wrap: /*@__PURE__*/configureNesting(defaultNesting, defaultAttrs)\n});\n/**\nLanguage support for HTML, including\n[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and\nCSS support extensions.\n*/\nfunction html(config = {}) {\n    let dialect = \"\", wrap;\n    if (config.matchClosingTags === false)\n        dialect = \"noMatch\";\n    if (config.selfClosingTags === true)\n        dialect = (dialect ? dialect + \" \" : \"\") + \"selfClosing\";\n    if (config.nestedLanguages && config.nestedLanguages.length ||\n        config.nestedAttributes && config.nestedAttributes.length)\n        wrap = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));\n    let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;\n    return new LanguageSupport(lang, [\n        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),\n        config.autoCloseTags !== false ? autoCloseTags : [],\n        javascript().support,\n        css().support\n    ]);\n}\nconst selfClosers = /*@__PURE__*/new Set(/*@__PURE__*/\"area base br col command embed frame hr img input keygen link meta param source track wbr menuitem\".split(\" \"));\n/**\nExtension that will automatically insert close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text) => {\n    if (view.composing || view.state.readOnly || from != to || (text != \">\" && text != \"/\") ||\n        !htmlLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let { state } = view;\n    let changes = state.changeByRange(range => {\n        var _a, _b, _c;\n        let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name;\n        if (around.name == \"TagName\" || around.name == \"StartTag\")\n            around = around.parent;\n        if (text == \">\" && around.name == \"OpenTag\") {\n            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != \"CloseTag\" &&\n                (name = elementName(state.doc, around.parent, head)) &&\n                !selfClosers.has(name)) {\n                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === \">\";\n                let insert = `${hasRightBracket ? \"\" : \">\"}</${name}>`;\n                return { range: EditorSelection.cursor(head + 1), changes: { from: head + (hasRightBracket ? 1 : 0), insert } };\n            }\n        }\n        else if (text == \"/\" && around.name == \"OpenTag\") {\n            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;\n            if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != \"CloseTag\" &&\n                (name = elementName(state.doc, base, head)) &&\n                !selfClosers.has(name)) {\n                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === \">\";\n                let insert = `/${name}${hasRightBracket ? \"\" : \">\"}`;\n                let pos = head + insert.length + (hasRightBracket ? 1 : 0);\n                return { range: EditorSelection.cursor(pos), changes: { from: head, insert } };\n            }\n        }\n        return { range };\n    });\n    if (changes.changes.empty)\n        return false;\n    view.dispatch(changes, { userEvent: \"input.type\", scrollIntoView: true });\n    return true;\n});\n\nexport { autoCloseTags, html, htmlCompletionSource, htmlCompletionSourceWith, htmlLanguage, htmlPlain };\n","import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["CompletionContext","constructor","state","pos","explicit","this","abortListeners","tokenBefore","types","token","syntaxTree","resolveInner","indexOf","name","parent","from","to","text","sliceDoc","type","matchBefore","expr","line","doc","lineAt","start","Math","max","str","slice","found","search","_a","source","addStart","addEnd","length","RegExp","flags","ignoreCase","ensureAnchor","aborted","addEventListener","listener","push","closedBracket","RangeValue","startSide","endSide","navigator","userAgent","Type","CompositeBlock","create","value","parentHash","end","hash","children","positions","hashProp","NodeProp","contextHash","addChild","child","prop","Tree","toTree","nodeSet","last","balance","makeTree","NodeType","none","LeafBlock","content","marks","parsers","Line","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","skipForList","bl","cx","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","reusePlaceholders","Map","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","parsedPos","finishContext","mark","reuseFragment","blockParsers","parse","leafBlockParsers","lines","stop","endLeafBlock","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","toRelative","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","startComposite","getNodeType","addElement","injectMarks","top","addGaps","tree","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dummies","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","reuse","get","propValues","MarkdownParser","Parser","blockNames","inlineParsers","inlineNames","wrappers","super","nodeTypes","Object","t","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","define","props","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Punctuation","DefaultInline","escaped","Escapable","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","emp","closeSize","k","element","findOpeningDelimiter","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","dummy","set","is","abs","gapFrom","gapTo","markdownHighlighting","tags","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","n","leftOverSpace","nextPos","StrikethroughDelim","Strikethrough","strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","delimiterLine","TableParser","rows","lineText","firstRow","Table","heading","TaskParser","GFM","atom","parseSubSuper","Superscript","special","Subscript","Emoji","match","_properties","properties","document","body","seen","Set","replace","toLowerCase","has","add","sort","pseudoClasses","values","identifier","variable","VariablesByNode","NodeWeakMap","declSelector","astTop","isTop","variableNames","isVariable","known","IterMode","IncludeAnonymous","option","iterate","matchContext","sliceString","cssCompletionSource","context","isDash","isError","options","validFor","callee","isVarArg","above","childBefore","defineCSSCompletionSource","cssLanguage","LRLanguage","indentNodeProp","Declaration","continuedIndent","foldNodeProp","Block","foldInside","languageData","commentTokens","indentOnInput","wordChars","Targets","Charsets","Methods","Encs","Bool","S","Tags","attrs","href","ping","media","target","hreflang","abbr","address","area","alt","coords","shape","article","aside","audio","src","mediagroup","crossorigin","preload","autoplay","loop","controls","bdi","bdo","blockquote","cite","br","button","form","formaction","autofocus","disabled","formenctype","formmethod","formnovalidate","formtarget","canvas","width","height","caption","center","code","col","span","colgroup","command","icon","radiogroup","checked","data","datagrid","multiple","datalist","dd","del","datetime","details","dfn","div","dl","dt","em","embed","eventsource","fieldset","figcaption","figure","footer","action","autocomplete","enctype","method","novalidate","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","manifest","iframe","srcdoc","sandbox","seamless","img","ismap","usemap","dirname","maxlength","pattern","placeholder","step","accept","readonly","required","ins","kbd","keygen","challenge","keytype","for","legend","li","sizes","menu","meta","charset","meter","low","high","optimum","nav","noscript","object","typemustmatch","ol","reversed","optgroup","selected","output","param","pre","progress","q","rp","rt","ruby","samp","script","async","defer","section","select","slot","small","scoped","sub","summary","sup","table","tbody","td","colspan","rowspan","headers","template","textarea","cols","tfoot","th","scope","thead","time","tr","track","default","kind","srclang","ul","var","video","poster","muted","wbr","GlobalAttrs","accesskey","class","contenteditable","contextmenu","dir","draggable","dropzone","hidden","inert","itemid","itemprop","itemref","itemscope","itemtype","lang","spellcheck","autocorrect","autocapitalize","tabindex","translate","rel","role","split","eventAttributes","Schema","extraTags","extraAttrs","globalAttrs","allTags","globalAttrNames","elementName","tag","getChild","findParentElement","allowedChildren","schema","parentInfo","openTags","tagName","lastChild","completeTag","apply","boost","completeCloseTag","htmlCompletionFor","around","scan","info","localAttrs","attrName","completeAttrName","nameNode","quoteStart","quoteEnd","completeAttrValue","level","completeStartTag","htmlCompletionSourceWith","extraGlobalAttributes","defaultNesting","defaultAttrs","htmlPlain","textAfter","continue","lineIndent","unit","column","endElt","bracketMatchingHandle","htmlLanguage","dialect","matchClosingTags","selfClosingTags","nestedLanguages","nestedAttributes","LanguageSupport","of","autoCloseTags","support","selfClosers","EditorView","inputHandler","view","composing","readOnly","isActiveAt","changes","changeByRange","range","_b","_c","hasRightBracket","insert","EditorSelection","empty","dispatch","userEvent","scrollIntoView","defineLanguageFacet","headingProp","commonmark","isHeading","isList","languageDataProp","findSectionEnd","headerNode","headerIndent","foldService","mkLang","Language","commonmarkLanguage","markdownLanguage","Context","spaceBefore","spaceAfter","item","blank","maxWidth","marker","number","String","itemNumber","getContext","renumberList","prev","normalizeIndent","facet","indentUnit","countColumn","insertNewlineContinueMarkup","dont","emptyLine","second","delTo","blankLine","lineBreak","prevLine","quoted","index","continued","charAt","line1","line2","nonTightList","update","isMark","deleteMarkupBackward","contextNodeForDelete","spaceEnd","markdownKeymap","key","run","htmlNoMatch","markdown","codeLanguages","defaultCodeLanguage","addKeymap","completeHTMLTags","defaultCode","extensions","language","codeParser","languages","defaultLanguage","LanguageDescription","matchLanguageName","ParseContext","getSkippingParser","load","htmlParser","parseMixed","overlay","infoNode","parseCode","Prec","keymap","htmlTagCompletion","htmlTagCompletions","_tagCompletions","EditorState"],"sourceRoot":""}