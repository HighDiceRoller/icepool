{"version":3,"file":"7835.7306cf9.js","mappings":"gRAKaA,EAAwB,IAAI,EAAAC,MAAM,6CAClCC,EAAc,GAAG,IAASC,MAAM,KAAKC,OAAO,GAAG,G,yBCF5D,MAAMC,EAAU,EAAAC,WAAWC,UAAU,cAE9B,MAAMC,EACT,WAAAC,CAAYC,GACR,IAAIC,EACJC,KAAKC,4BAA8BC,MAAOC,IACtC,MAAMC,EAAa,GAAGD,YAGhBE,EAAmBC,aAAaC,QAAQH,GAC9C,GAAKC,GAAoBA,IAAqBZ,IAAaY,EAAkB,CAEzEG,QAAQC,KAAK,wDACb,MAAMC,QAAsBC,UAAUC,cAAcC,yBAC9CC,QAAQC,IAAIL,EAAcM,KAAKC,GAAiBA,EAAaC,gBAEnEV,QAAQC,KAAK,uDACjB,CACAH,aAAaa,QAAQf,EAAYX,EAAQ,EAE7CO,KAAKoB,mBAAqBlB,UACtB,MAAMmB,QAAiBC,MApBV,iCAsBA,aADMD,EAASE,QAExBC,WAAWxB,KAAKoB,mBAAoB,IACxC,EAEJpB,KAAKyB,cAAgB,KACrBzB,KAAK0B,qBAAuB,IAAI,EAAAC,OAAO3B,MACvCA,KAAK4B,OAAS,IAAI,EAAAC,gBAClB,MAAMC,EAA2F,QAA9E/B,EAAKD,aAAyC,EAASA,EAAQgC,iBAA8B,IAAP/B,EAAgBA,EAAK,EAAAgC,OAAOC,KAAK,EAAAtC,WAAWuC,aAAc3C,GAC7J4C,EAAgB,IAAIC,IAAIL,EAAWM,OAAOC,SAASC,MACnDC,EAAc,EAAA7C,WAAWC,UAAU,6BAA+B,QACxEuC,EAAcM,aAAaC,IAAI,cAAeF,GACzCvC,KAAK0C,WAAWR,EAAcI,MAAMK,MAAMnC,QAAQoC,KAC3D,CAIA,uBAAIC,GACA,OAAO7C,KAAK0B,oBAChB,CAIA,WAAIoB,GACA,OAA8B,OAAvB9C,KAAKyB,aAChB,CACA,SAAIsB,GACA,OAAO/C,KAAK4B,OAAOoB,OACvB,CACA,gBAAMN,CAAWZ,GACb,MAAM,cAAElB,GAAkBD,UAC1B,IAAIM,EAAe,KACnB,GAAKL,GAGA,GAAIA,EAAcqC,WAAY,CAC/B,MAAM9C,EAAYS,EAAcqC,WAAW9C,gBACrCH,KAAKC,4BAA4BE,GACvCc,QAAsBL,EAAcsC,gBAAgB/C,IAAe,KAEnEK,QAAQC,KAAK,mDACjB,OARID,QAAQoC,KAAK,gDASjB,IAAK3B,GAAgBL,EACjB,IAEIJ,QAAQC,KAAK,4CAA6CqB,GAC1Db,QAAqBL,EAAcuC,SAASrB,GAE5CtB,QAAQC,KAAK,uDACjB,CACA,MAAO2C,GACH5C,QAAQoC,KAAKQ,GACb5C,QAAQoC,KAAK,+DAA+DQ,IAChF,CAEJpD,KAAKqD,iBAAiBpC,GACjBA,GAIDjB,KAAK4B,OAAO0B,aAAQ,GACpB9B,WAAWxB,KAAKoB,mBAAoB,MAJpCpB,KAAK4B,OAAO2B,YAAO,EAM3B,CACA,gBAAAF,CAAiBpC,GACbjB,KAAKyB,cAAgBR,EACrBjB,KAAK0B,qBAAqB8B,KAAKxD,KAAKyB,cACxC,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/service-worker-manager.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\nimport SW_URL from './service-worker?text';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token('@jupyterlite/server:IServiceWorkerManager');\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n//# sourceMappingURL=tokens.js.map","import { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { WORKER_NAME } from './tokens';\nconst VERSION = PageConfig.getOption('appVersion');\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\nexport class ServiceWorkerManager {\n    constructor(options) {\n        var _a;\n        this.unregisterOldServiceWorkers = async (scriptURL) => {\n            const versionKey = `${scriptURL}-version`;\n            // Check if we have an installed version. If we do, compare it to the current version\n            // and unregister all service workers if they are different.\n            const installedVersion = localStorage.getItem(versionKey);\n            if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {\n                // eslint-disable-next-line no-console\n                console.info('New version, unregistering existing service workers.');\n                const registrations = await navigator.serviceWorker.getRegistrations();\n                await Promise.all(registrations.map((registration) => registration.unregister()));\n                // eslint-disable-next-line no-console\n                console.info('All existing service workers have been unregistered.');\n            }\n            localStorage.setItem(versionKey, VERSION);\n        };\n        this._pingServiceWorker = async () => {\n            const response = await fetch(SW_PING_ENDPOINT);\n            const text = await response.text();\n            if (text === 'ok') {\n                setTimeout(this._pingServiceWorker, 20000);\n            }\n        };\n        this._registration = null;\n        this._registrationChanged = new Signal(this);\n        this._ready = new PromiseDelegate();\n        const workerUrl = (_a = options === null || options === void 0 ? void 0 : options.workerUrl) !== null && _a !== void 0 ? _a : URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        void this.initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    async initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this.unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n}\n//# sourceMappingURL=service-worker-manager.js.map"],"names":["IServiceWorkerManager","Token","WORKER_NAME","split","slice","VERSION","PageConfig","getOption","ServiceWorkerManager","constructor","options","_a","this","unregisterOldServiceWorkers","async","scriptURL","versionKey","installedVersion","localStorage","getItem","console","info","registrations","navigator","serviceWorker","getRegistrations","Promise","all","map","registration","unregister","setItem","_pingServiceWorker","response","fetch","text","setTimeout","_registration","_registrationChanged","Signal","_ready","PromiseDelegate","workerUrl","URLExt","join","getBaseUrl","fullWorkerUrl","URL","window","location","href","enableCache","searchParams","set","initialize","catch","warn","registrationChanged","enabled","ready","promise","controller","getRegistration","register","err","_setRegistration","resolve","reject","emit"],"sourceRoot":""}