{"version":3,"file":"4884.7d948f6.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport const DRIVE_SEPARATOR = ':';\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n            stream.file = undefined;\n        }\n    }\n    read(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        const size = Math.min(((_a = stream.file.data.length) !== null && _a !== void 0 ? _a : 0) - position, length);\n        try {\n            buffer.set(stream.file.data.subarray(position, position + size), offset);\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a, _b;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        try {\n            if (position + length > ((_b = (_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) !== null && _b !== void 0 ? _b : 0)) {\n                const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n                stream.file.data = new Uint8Array(position + length);\n                stream.file.data.set(oldData);\n            }\n            stream.file.data.set(buffer.subarray(offset, offset + length), position);\n            return length;\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EINVAL']);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    getattr(node) {\n        return this.fs.API.getattr(this.fs.realPath(node));\n    }\n    setattr(node, attr) {\n        // TODO\n    }\n    lookup(parent, name) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n        }\n        return this.fs.createNode(parent, name, result.mode);\n    }\n    mknod(parent, name, mode, dev) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(parent, name, mode, dev);\n    }\n    rename(oldNode, newDir, newName) {\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDir), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    readdir(node) {\n        return this.fs.API.readdir(this.fs.realPath(node));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        this._baseUrl = baseUrl;\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    request(method, path, data = null) {\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, encodeURI(`${this.endpoint}${path}`), false);\n        try {\n            if (data === null) {\n                xhr.send();\n            }\n            else {\n                xhr.send(data);\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    lookup(path) {\n        return this.request('GET', `${this.normalizePath(path)}?m=lookup`);\n    }\n    getmode(path) {\n        return Number.parseInt(this.request('GET', `${this.normalizePath(path)}?m=getmode`));\n    }\n    mknod(path, mode) {\n        return this.request('GET', `${this.normalizePath(path)}?m=mknod&args=${mode}`);\n    }\n    rename(oldPath, newPath) {\n        return this.request('GET', `${this.normalizePath(oldPath)}?m=rename&args=${this.normalizePath(newPath)}`);\n    }\n    readdir(path) {\n        const dirlist = this.request('GET', `${this.normalizePath(path)}?m=readdir`);\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request('GET', `${this.normalizePath(path)}?m=rmdir`);\n    }\n    get(path) {\n        const response = this.request('GET', `${this.normalizePath(path)}?m=get`);\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request('PUT', `${this.normalizePath(path)}?m=put&args=${value.format}`, decoder.decode(value.data));\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request('PUT', `${this.normalizePath(path)}?m=put&args=${value.format}`, btoa(binary));\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request('GET', `${this.normalizePath(path)}?m=getattr`);\n        // Turn datetimes into proper objects\n        stats.atime = new Date(stats.atime);\n        stats.mtime = new Date(stats.mtime);\n        stats.ctime = new Date(stats.ctime);\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive/`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = new ContentsAPI(options.baseUrl, options.driveName, options.mountpoint, this.FS, this.ERRNO_CODES);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n","import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: undefined,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: undefined,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: undefined,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        let item = await this.get(path);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            if (ext === '.ipynb') {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'notebook',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'file',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                item = {\n                    ...item,\n                    content: this.unescapeContent(options.content),\n                    format: 'text',\n                    type: 'file',\n                };\n            }\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    unescapeContent(content) {\n        return decodeURIComponent(escape(atob(content)));\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: undefined,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            content: null,\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(new Uint8Array(await response.arrayBuffer()).reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, PathExt } from '@jupyterlab/coreutils';\nimport { Contents, DIR_MODE, FILE_MODE, IContents, } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { IServiceWorkerRegistrationWrapper, ServiceWorkerRegistrationWrapper, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\nimport localforage from 'localforage';\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerRegistrationWrapper,\n    activate: (app) => {\n        return new ServiceWorkerRegistrationWrapper();\n    },\n};\n/**\n * A plugin handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    activate: (app) => {\n        // Setup communication with service worker for the virtual fs\n        const broadcast = new BroadcastChannel('/api/drive.v1');\n        let subitems;\n        broadcast.onmessage = async (event) => {\n            const request = event.data;\n            const contentManager = app.serviceManager.contents;\n            const path = request.path.replace('/api/drive/', '');\n            let model;\n            switch (request.method) {\n                case 'readdir': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory' && model.content) {\n                        subitems = model.content.map((subcontent) => subcontent.name);\n                        broadcast.postMessage(subitems);\n                    }\n                    else {\n                        broadcast.postMessage([]);\n                    }\n                    break;\n                }\n                case 'rmdir': {\n                    await contentManager.delete(path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'rename': {\n                    if (request.args === null) {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    await contentManager.rename(path, request.args[0]);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getmode': {\n                    model = await contentManager.get(path);\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(DIR_MODE);\n                    }\n                    else {\n                        broadcast.postMessage(FILE_MODE);\n                    }\n                    break;\n                }\n                case 'lookup': {\n                    try {\n                        model = await contentManager.get(path);\n                        broadcast.postMessage({\n                            ok: true,\n                            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        });\n                    }\n                    catch (e) {\n                        broadcast.postMessage({\n                            ok: false,\n                        });\n                    }\n                    break;\n                }\n                case 'mknod': {\n                    if (request.args === null) {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    const mode = Number.parseInt(request.args[0]);\n                    model = await contentManager.newUntitled({\n                        path: PathExt.dirname(path),\n                        type: mode === DIR_MODE ? 'directory' : 'file',\n                        ext: PathExt.extname(path),\n                    });\n                    await contentManager.rename(model.path, path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getattr': {\n                    model = await contentManager.get(path);\n                    broadcast.postMessage({\n                        dev: 0,\n                        ino: 0,\n                        mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        nlink: 0,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size: model.size,\n                        blksize: 0,\n                        blocks: 0,\n                        atime: model.last_modified,\n                        mtime: model.last_modified,\n                        ctime: model.last_modified,\n                        timestamp: 0,\n                    });\n                    break;\n                }\n                case 'get': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    let content = model.content;\n                    if (model.format === 'json') {\n                        content = JSON.stringify(model.content);\n                    }\n                    broadcast.postMessage({\n                        content,\n                        format: model.format,\n                    });\n                    break;\n                }\n                case 'put': {\n                    if (request.args === null) {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    await contentManager.save(path, {\n                        content: request.content,\n                        type: 'file',\n                        format: request.args[0],\n                    });\n                    broadcast.postMessage(null);\n                    break;\n                }\n            }\n        };\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec !== null && spec !== void 0 ? spec : {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n"],"names":["DIR_MODE","FILE_MODE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","constructor","fs","this","open","stream","path","realPath","node","FS","isFile","mode","file","API","get","close","flags","parsedFlags","parseInt","needsWrite","put","undefined","read","buffer","offset","length","position","_a","size","Math","min","data","set","subarray","e","ErrnoError","ERRNO_CODES","write","_b","timestamp","Date","now","oldData","Uint8Array","llseek","whence","DriveFSEmscriptenNodeOps","getattr","setattr","attr","lookup","parent","name","PATH","join2","result","ok","genericErrors","createNode","mknod","dev","rename","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","method","xhr","XMLHttpRequest","encodeURI","endpoint","send","console","error","status","JSON","parse","responseText","normalizePath","getmode","Number","newPath","dirlist","push","response","serializedContent","content","format","encode","binString","atob","len","i","charCodeAt","value","decode","binary","byteLength","String","fromCharCode","btoa","stats","atime","mtime","ctime","startsWith","slice","DriveFS","options","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","join","apply","IContents","Token","MIME","FILE","PLAIN_TEXT","OCTET_STREAM","TYPES","PageConfig","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","hasFormat","fileFormat","DEFAULT_STORAGE_NAME","Contents","reduceBytesToString","byte","_serverContents","Map","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","async","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","createInstance","description","storeName","_c","type","created","toISOString","dirname","PathExt","basename","extname","item","_incrementCounter","last_modified","mimetype","writable","counter","Private","EMPTY_NB","stringify","indexOf","key","setItem","toDir","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","serverContents","Array","from","_getServerDirectory","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","URLExt","newUntitled","unescapeContent","escape","slashed","toDelete","keys","filter","Promise","all","map","forgetPath","copies","Boolean","splice","id","normalizeCheckpoint","toString","checkpointID","includes","fileUrl","fetch","headers","match","json","text","arrayBuffer","reduce","apiURL","err","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","localforagePlugin","autoStart","provides","ILocalForage","activate","app","localforageMemoryPlugin","requires","forage","ensureMemoryStorage","contentsPlugin","contents","started","initialize","catch","contentsRoutesPlugin","router","req","filename","res","listCheckpoints","Response","post","checkpoint","restoreCheckpoint","createCheckpoint","delete","deleteCheckpoint","query","nb","body","copyFrom","copy_from","copy","patch","save","serviceWorkerPlugin","IServiceWorkerRegistrationWrapper","ServiceWorkerRegistrationWrapper","emscriptenFileSystemPlugin","broadcast","BroadcastChannel","subitems","onmessage","event","contentManager","serviceManager","subcontent","postMessage","args","ino","nlink","uid","gid","rdev","blksize","blocks","kernelsPlugin","IKernels","IKernelSpecs","kernelspecs","Kernels","kernelsRoutesPlugin","kernels","kernelId","restart","shutdown","kernelSpecPlugin","KernelSpecs","kernelSpecRoutesPlugin","specs","allKernelSpecs","allSpecs","forEach","spec","resources","default","licensesPlugin","ILicenses","Licenses","licensesRoutesPlugin","licenses","nbconvertRoutesPlugin","sessionsPlugin","ISessions","Sessions","sessionsRoutesPlugin","sessions","session","list","startNew","settingsPlugin","ISettings","settings","Settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale"],"sourceRoot":""}