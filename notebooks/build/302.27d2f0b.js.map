{"version":3,"file":"302.27d2f0b.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/contents.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/emscripten.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/drivefs.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/broadcast.ts"],"sourcesContent":["import { IDisposable } from '@lumino/disposable';\nimport { IRenderMime } from '@jupyterlab/rendermime-interfaces';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\n\nimport { Contents as ServerContents } from '@jupyterlab/services';\n\nimport { Token } from '@lumino/coreutils';\n\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token<IContents>('@jupyterlite/contents:IContents');\n\n/**\n * The interface for the contents service.\n */\nexport interface IContents {\n  /**\n   * A promise that resolves after the contents have been full initialized.\n   */\n  ready: Promise<void>;\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the file is created.\n   */\n  newUntitled(\n    options?: ServerContents.ICreateOptions\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param path - The original file path.\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   */\n  copy(path: string, toDir: string): Promise<ServerContents.IModel>;\n\n  /**\n   * Get a file or directory.\n   *\n   * @param path: The path to the file.\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   */\n  get(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldLocalPath - The original file path.\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file content model when the file is renamed.\n   */\n  rename(oldLocalPath: string, newLocalPath: string): Promise<ServerContents.IModel>;\n\n  /**\n   * Save a file.\n   *\n   * @param path - The desired file path.\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the file is saved.\n   */\n  save(\n    path: string,\n    options?: Partial<ServerContents.IModel>\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Delete a file.\n   *\n   * @param path - The path to the file.\n   */\n  delete(path: string): Promise<void>;\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   */\n  createCheckpoint(path: string): Promise<ServerContents.ICheckpointModel>;\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   */\n  listCheckpoints(path: string): Promise<ServerContents.ICheckpointModel[]>;\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   */\n  restoreCheckpoint(path: string, checkpointID: string): Promise<void>;\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   */\n  deleteCheckpoint(path: string, checkpointID: string): Promise<void>;\n}\n\n/**\n * Commonly-used mimetypes\n */\nexport namespace MIME {\n  export const JSON = 'application/json';\n  export const PLAIN_TEXT = 'text/plain';\n  export const OCTET_STREAM = 'octet/stream';\n}\n\n/**\n * A namespace for file constructs.\n */\nexport namespace FILE {\n  /**\n   * Build-time configured file types.\n   */\n  const TYPES: Record<string, Partial<IRenderMime.IFileType>> = JSON.parse(\n    PageConfig.getOption('fileTypes') || '{}'\n  );\n\n  /**\n   * Get a mimetype (or fallback).\n   */\n  export function getType(ext: string, defaultType: string | null = null): string {\n    ext = ext.toLowerCase();\n    for (const fileType of Object.values(TYPES)) {\n      for (const fileExt of fileType.extensions || []) {\n        if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n          return fileType.mimeTypes[0];\n        }\n      }\n    }\n\n    return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n  }\n\n  /**\n   * Determine whether the given extension matches a given fileFormat.\n   */\n  export function hasFormat(\n    ext: string,\n    fileFormat: 'base64' | 'text' | 'json'\n  ): boolean {\n    ext = ext.toLowerCase();\n    for (const fileType of Object.values(TYPES)) {\n      if (fileType.fileFormat !== fileFormat) {\n        continue;\n      }\n      for (const fileExt of fileType.extensions || []) {\n        if (fileExt === ext) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * The token for the BroadcastChannel broadcaster.\n */\nexport const IBroadcastChannelWrapper = new Token<IBroadcastChannelWrapper>(\n  '@jupyterlite/contents:IBroadcastChannelWrapper'\n);\n\nexport interface IBroadcastChannelWrapper extends IDisposable {\n  enable(): void;\n  disable(): void;\n  enabled: boolean;\n}\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\n\nimport { Contents as ServerContents } from '@jupyterlab/services';\n\nimport { INotebookContent } from '@jupyterlab/nbformat';\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport type localforage from 'localforage';\n\nimport { IContents, MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n\nexport type IModel = ServerContents.IModel;\n\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents implements IContents {\n  /**\n   * Construct a new localForage-powered contents provider\n   */\n  constructor(options: Contents.IOptions) {\n    this._localforage = options.localforage;\n    this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n    this._storageDrivers = options.storageDrivers || null;\n    this._ready = new PromiseDelegate();\n  }\n\n  /**\n   * Finish any initialization after server has started and all extensions are applied.\n   */\n  async initialize() {\n    await this.initStorage();\n    this._ready.resolve(void 0);\n  }\n\n  /**\n   * Initialize all storage instances\n   */\n  protected async initStorage(): Promise<void> {\n    this._storage = this.createDefaultStorage();\n    this._counters = this.createDefaultCounters();\n    this._checkpoints = this.createDefaultCheckpoints();\n  }\n\n  /**\n   * A promise that resolves once all storage is fully initialized.\n   */\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  /**\n   * A lazy reference to the underlying storage.\n   */\n  protected get storage(): Promise<LocalForage> {\n    return this.ready.then(() => this._storage as LocalForage);\n  }\n\n  /**\n   * A lazy reference to the underlying counters.\n   */\n  protected get counters(): Promise<LocalForage> {\n    return this.ready.then(() => this._counters as LocalForage);\n  }\n\n  /**\n   * A lazy reference to the underlying checkpoints.\n   */\n  protected get checkpoints(): Promise<LocalForage> {\n    return this.ready.then(() => this._checkpoints as LocalForage);\n  }\n\n  /**\n   * Get default options for localForage instances\n   */\n  protected get defaultStorageOptions(): LocalForageOptions {\n    const driver =\n      this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n    return {\n      version: 1,\n      name: this._storageName,\n      ...(driver ? { driver } : {}),\n    };\n  }\n\n  /**\n   * Initialize the default storage for contents.\n   */\n  protected createDefaultStorage(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Offline Storage for Notebooks and Files',\n      storeName: 'files',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Initialize the default storage for counting file suffixes.\n   */\n  protected createDefaultCounters(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Store the current file suffix counters',\n      storeName: 'counters',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Create the default checkpoint storage.\n   */\n  protected createDefaultCheckpoints(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Offline Storage for Checkpoints',\n      storeName: 'checkpoints',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the file is created.\n   */\n  async newUntitled(options?: ServerContents.ICreateOptions): Promise<IModel | null> {\n    const path = options?.path ?? '';\n    const type = options?.type ?? 'notebook';\n    const created = new Date().toISOString();\n\n    let dirname = PathExt.dirname(path);\n    const basename = PathExt.basename(path);\n    const extname = PathExt.extname(path);\n    const item = await this.get(dirname);\n\n    // handle the case of \"Save As\", where the path points to the new file\n    // to create, e.g. subfolder/example-copy.ipynb\n    let name = '';\n    if (path && !extname && item) {\n      // directory\n      dirname = `${path}/`;\n      name = '';\n    } else if (dirname && basename) {\n      // file in a subfolder\n      dirname = `${dirname}/`;\n      name = basename;\n    } else {\n      // file at the top level\n      dirname = '';\n      name = path;\n    }\n\n    let file: IModel;\n    switch (type) {\n      case 'directory': {\n        const counter = await this._incrementCounter('directory');\n        name = `Untitled Folder${counter || ''}`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format: 'json',\n          mimetype: '',\n          content: null,\n          size: 0,\n          writable: true,\n          type: 'directory',\n        };\n        break;\n      }\n      case 'notebook': {\n        const counter = await this._incrementCounter('notebook');\n        name = name || `Untitled${counter || ''}.ipynb`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format: 'json',\n          mimetype: MIME.JSON,\n          content: Private.EMPTY_NB,\n          size: JSON.stringify(Private.EMPTY_NB).length,\n          writable: true,\n          type: 'notebook',\n        };\n        break;\n      }\n      default: {\n        const ext = options?.ext ?? '.txt';\n        const counter = await this._incrementCounter('file');\n        const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n\n        let format: ServerContents.FileFormat;\n        if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n          format = 'text';\n        } else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n          format = 'json';\n        } else {\n          format = 'base64';\n        }\n\n        name = name || `untitled${counter || ''}${ext}`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format,\n          mimetype,\n          content: '',\n          size: 0,\n          writable: true,\n          type: 'file',\n        };\n        break;\n      }\n    }\n\n    const key = file.path;\n    await (await this.storage).setItem(key, file);\n    return file;\n  }\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param path - The original file path.\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   */\n  async copy(path: string, toDir: string): Promise<IModel> {\n    let name = PathExt.basename(path);\n    toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n    // TODO: better handle naming collisions with existing files\n    while (await this.get(`${toDir}${name}`, { content: true })) {\n      const ext = PathExt.extname(name);\n      const base = name.replace(ext, '');\n      name = `${base} (copy)${ext}`;\n    }\n    const toPath = `${toDir}${name}`;\n    let item = await this.get(path, { content: true });\n    if (!item) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    item = {\n      ...item,\n      name,\n      path: toPath,\n    };\n    await (await this.storage).setItem(toPath, item);\n    return item;\n  }\n\n  /**\n   * Get a file or directory.\n   *\n   * @param path: The path to the file.\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   */\n  async get(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<IModel | null> {\n    // remove leading slash\n    path = decodeURIComponent(path.replace(/^\\//, ''));\n\n    if (path === '') {\n      return await this._getFolder(path);\n    }\n\n    const storage = await this.storage;\n    const item = await storage.getItem(path);\n    const serverItem = await this._getServerContents(path, options);\n\n    const model = (item || serverItem) as IModel | null;\n\n    if (!model) {\n      return null;\n    }\n\n    if (!options?.content) {\n      return {\n        size: 0,\n        ...model,\n        content: null,\n      };\n    }\n\n    // for directories, find all files with the path as the prefix\n    if (model.type === 'directory') {\n      const contentMap = new Map<string, IModel>();\n      await storage.iterate<IModel, void>((file, key) => {\n        // use an additional slash to not include the directory itself\n        if (key === `${path}/${file.name}`) {\n          contentMap.set(file.name, file);\n        }\n      });\n\n      const serverContents: IModel[] = serverItem\n        ? serverItem.content\n        : Array.from((await this._getServerDirectory(path)).values());\n      for (const file of serverContents) {\n        if (!contentMap.has(file.name)) {\n          contentMap.set(file.name, file);\n        }\n      }\n\n      const content = [...contentMap.values()];\n\n      return {\n        name: PathExt.basename(path),\n        path,\n        last_modified: model.last_modified,\n        created: model.created,\n        format: 'json',\n        mimetype: MIME.JSON,\n        content,\n        size: 0,\n        writable: true,\n        type: 'directory',\n      };\n    }\n    return model;\n  }\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldLocalPath - The original file path.\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file content model when the file is renamed.\n   */\n  async rename(oldLocalPath: string, newLocalPath: string): Promise<IModel> {\n    const path = decodeURIComponent(oldLocalPath);\n    const file = await this.get(path, { content: true });\n    if (!file) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    const modified = new Date().toISOString();\n    const name = PathExt.basename(newLocalPath);\n    const newFile = {\n      ...file,\n      name,\n      path: newLocalPath,\n      last_modified: modified,\n    };\n    const storage = await this.storage;\n    await storage.setItem(newLocalPath, newFile);\n    // remove the old file\n    await storage.removeItem(path);\n    // remove the corresponding checkpoint\n    await (await this.checkpoints).removeItem(path);\n    // if a directory, recurse through all children\n    if (file.type === 'directory') {\n      let child: IModel;\n      for (child of file.content) {\n        await this.rename(\n          URLExt.join(oldLocalPath, child.name),\n          URLExt.join(newLocalPath, child.name)\n        );\n      }\n    }\n\n    return newFile;\n  }\n\n  /**\n   * Save a file.\n   *\n   * @param path - The desired file path.\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the file is saved.\n   */\n  async save(path: string, options: Partial<IModel> = {}): Promise<IModel | null> {\n    path = decodeURIComponent(path);\n\n    // process the file if coming from an upload\n    const ext = PathExt.extname(options.name ?? '');\n\n    let item: IModel | null = await this.get(path);\n\n    if (!item) {\n      item = await this.newUntitled({ path, ext, type: 'file' });\n    }\n\n    if (!item) {\n      return null;\n    }\n\n    // override with the new values\n    const modified = new Date().toISOString();\n    item = {\n      ...item,\n      ...options,\n      last_modified: modified,\n    };\n\n    if (options.content && options.format === 'base64') {\n      if (ext === '.ipynb') {\n        const contentUnescaped = this.unescapeContent(options.content);\n        const size = contentUnescaped.length;\n        item = {\n          ...item,\n          content: JSON.parse(contentUnescaped),\n          format: 'json',\n          type: 'notebook',\n          size: size,\n        };\n      } else if (FILE.hasFormat(ext, 'json')) {\n        const contentUnescaped = this.unescapeContent(options.content);\n        const size = contentUnescaped.length;\n        item = {\n          ...item,\n          content: JSON.parse(contentUnescaped),\n          format: 'json',\n          type: 'file',\n          size: size,\n        };\n      } else if (FILE.hasFormat(ext, 'text')) {\n        const contentUnescaped = this.unescapeContent(options.content);\n        const size = contentUnescaped.length;\n        item = {\n          ...item,\n          content: contentUnescaped,\n          format: 'text',\n          type: 'file',\n          size: size,\n        };\n      } else {\n        item = {\n          ...item,\n          size: atob(options.content).length,\n        };\n      }\n    }\n\n    await (await this.storage).setItem(path, item);\n    return item;\n  }\n\n  unescapeContent(content: string): string {\n    return decodeURIComponent(escape(atob(content)));\n  }\n\n  /**\n   * Delete a file from browser storage.\n   *\n   * Has no effect on server-backed files, which will re-appear with their\n   * original timestamp.\n   *\n   * @param path - The path to the file.\n   */\n  async delete(path: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const slashed = `${path}/`;\n    const toDelete = (await (await this.storage).keys()).filter(\n      (key) => key === path || key.startsWith(slashed)\n    );\n    await Promise.all(toDelete.map(this.forgetPath, this));\n  }\n\n  /**\n   * Remove the localForage and checkpoints for a path.\n   *\n   * @param path - The path to the file\n   */\n  protected async forgetPath(path: string): Promise<void> {\n    await Promise.all([\n      (await this.storage).removeItem(path),\n      (await this.checkpoints).removeItem(path),\n    ]);\n  }\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   */\n  async createCheckpoint(path: string): Promise<ServerContents.ICheckpointModel> {\n    const checkpoints = await this.checkpoints;\n    path = decodeURIComponent(path);\n    const item = await this.get(path, { content: true });\n    if (!item) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    const copies = (((await checkpoints.getItem(path)) as IModel[]) ?? []).filter(\n      Boolean\n    );\n    copies.push(item);\n    // keep only a certain amount of checkpoints per file\n    if (copies.length > N_CHECKPOINTS) {\n      copies.splice(0, copies.length - N_CHECKPOINTS);\n    }\n    await checkpoints.setItem(path, copies);\n    const id = `${copies.length - 1}`;\n    return { id, last_modified: (item as IModel).last_modified };\n  }\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   */\n  async listCheckpoints(path: string): Promise<ServerContents.ICheckpointModel[]> {\n    const copies: IModel[] = (await (await this.checkpoints).getItem(path)) || [];\n    return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n  }\n\n  protected normalizeCheckpoint(\n    model: IModel,\n    id: number\n  ): ServerContents.ICheckpointModel {\n    return { id: id.toString(), last_modified: model.last_modified };\n  }\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   */\n  async restoreCheckpoint(path: string, checkpointID: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const copies = ((await (await this.checkpoints).getItem(path)) || []) as IModel[];\n    const id = parseInt(checkpointID);\n    const item = copies[id];\n    await (await this.storage).setItem(path, item);\n  }\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   */\n  async deleteCheckpoint(path: string, checkpointID: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const copies = ((await (await this.checkpoints).getItem(path)) || []) as IModel[];\n    const id = parseInt(checkpointID);\n    copies.splice(id, 1);\n    await (await this.checkpoints).setItem(path, copies);\n  }\n\n  /**\n   * retrieve the contents for this path from the union of local storage and\n   * `api/contents/{path}/all.json`.\n   *\n   * @param path - The contents path to retrieve\n   *\n   * @returns A promise which resolves with a Map of contents, keyed by local file name\n   */\n  private async _getFolder(path: string): Promise<IModel | null> {\n    const content = new Map<string, IModel>();\n    const storage = await this.storage;\n    await storage.iterate<IModel, void>((file, key) => {\n      if (key.includes('/')) {\n        return;\n      }\n      content.set(file.path, file);\n    });\n\n    // layer in contents that don't have local overwrites\n    for (const file of (await this._getServerDirectory(path)).values()) {\n      if (!content.has(file.path)) {\n        content.set(file.path, file);\n      }\n    }\n\n    if (path && content.size === 0) {\n      return null;\n    }\n\n    return {\n      name: '',\n      path,\n      last_modified: new Date(0).toISOString(),\n      created: new Date(0).toISOString(),\n      format: 'json',\n      mimetype: MIME.JSON,\n      content: Array.from(content.values()),\n      size: 0,\n      writable: true,\n      type: 'directory',\n    };\n  }\n\n  /**\n   * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n   * deriving the model (including content) off the file in `/files/`. Otherwise\n   * return `null`.\n   */\n  private async _getServerContents(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<IModel | null> {\n    const name = PathExt.basename(path);\n    const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n    let model = parentContents.get(name);\n    if (!model) {\n      return null;\n    }\n    model = model || {\n      name,\n      path,\n      last_modified: new Date(0).toISOString(),\n      created: new Date(0).toISOString(),\n      format: 'text',\n      mimetype: MIME.PLAIN_TEXT,\n      type: 'file',\n      writable: true,\n      size: 0,\n      content: '',\n    };\n\n    if (options?.content) {\n      if (model.type === 'directory') {\n        const serverContents = await this._getServerDirectory(path);\n        model = { ...model, content: Array.from(serverContents.values()) };\n      } else {\n        const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n        const response = await fetch(fileUrl);\n        if (!response.ok) {\n          return null;\n        }\n        const mimetype = model.mimetype || response.headers.get('Content-Type');\n        const ext = PathExt.extname(name);\n\n        if (\n          model.type === 'notebook' ||\n          FILE.hasFormat(ext, 'json') ||\n          mimetype?.indexOf('json') !== -1 ||\n          path.match(/\\.(ipynb|[^/]*json[^/]*)$/)\n        ) {\n          const contentText = await response.text();\n          model = {\n            ...model,\n            content: JSON.parse(contentText),\n            format: 'json',\n            mimetype: model.mimetype || MIME.JSON,\n            size: contentText.length,\n          };\n        } else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n          const contentText = await response.text();\n          model = {\n            ...model,\n            content: contentText,\n            format: 'text',\n            mimetype: mimetype || MIME.PLAIN_TEXT,\n            size: contentText.length,\n          };\n        } else {\n          const contentBytes = await response.arrayBuffer();\n          const contentBuffer = new Uint8Array(contentBytes);\n          model = {\n            ...model,\n            content: btoa(contentBuffer.reduce(this.reduceBytesToString, '')),\n            format: 'base64',\n            mimetype: mimetype || MIME.OCTET_STREAM,\n            size: contentBuffer.length,\n          };\n        }\n      }\n    }\n\n    return model;\n  }\n\n  /**\n   * A reducer for turning arbitrary binary into a string\n   */\n  protected reduceBytesToString = (data: string, byte: number): string => {\n    return data + String.fromCharCode(byte);\n  };\n\n  /**\n   * retrieve the contents for this path from `__index__.json` in the appropriate\n   * folder.\n   *\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with a Map of contents, keyed by local file name\n   */\n  private async _getServerDirectory(path: string): Promise<Map<string, IModel>> {\n    const content = this._serverContents.get(path) || new Map();\n\n    if (!this._serverContents.has(path)) {\n      const apiURL = URLExt.join(\n        PageConfig.getBaseUrl(),\n        'api/contents',\n        path,\n        'all.json'\n      );\n\n      try {\n        const response = await fetch(apiURL);\n        const json = JSON.parse(await response.text());\n        for (const file of json['content'] as IModel[]) {\n          content.set(file.name, file);\n        }\n      } catch (err) {\n        console.warn(\n          `don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`\n        );\n      }\n      this._serverContents.set(path, content);\n    }\n\n    return content;\n  }\n\n  /**\n   * Increment the counter for a given file type.\n   * Used to avoid collisions when creating new untitled files.\n   *\n   * @param type The file type to increment the counter for.\n   */\n  private async _incrementCounter(type: ServerContents.ContentType): Promise<number> {\n    const counters = await this.counters;\n    const current = ((await counters.getItem(type)) as number) ?? -1;\n    const counter = current + 1;\n    await counters.setItem(type, counter);\n    return counter;\n  }\n\n  private _serverContents = new Map<string, Map<string, IModel>>();\n  private _storageName: string = DEFAULT_STORAGE_NAME;\n  private _storageDrivers: string[] | null = null;\n  private _ready: PromiseDelegate<void>;\n  private _storage: LocalForage | undefined;\n  private _counters: LocalForage | undefined;\n  private _checkpoints: LocalForage | undefined;\n  private _localforage: typeof localforage;\n}\n\n/**\n * A namespace for contents information.\n */\nexport namespace Contents {\n  export interface IOptions {\n    /**\n     * The name of the storage instance on e.g. IndexedDB, localStorage\n     */\n    storageName?: string | null;\n    storageDrivers?: string[] | null;\n    localforage: typeof localforage;\n  }\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * The content for an empty notebook.\n   */\n  export const EMPTY_NB: INotebookContent = {\n    metadata: {\n      orig_nbformat: 4,\n    },\n    nbformat_minor: 4,\n    nbformat: 4,\n    cells: [],\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\n\n/**\n * Types for Emscripten primitives.\n *\n * Ideally, much more of these would be taken from `@types/emscripten`.\n */\n\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../../node_modules/@types/emscripten/index.d.ts\" />\ntype EmscriptenFS = typeof FS;\n\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\n\nexport interface IStats {\n  dev: number;\n  ino: number;\n  mode: number;\n  nlink: number;\n  uid: number;\n  gid: number;\n  rdev: number;\n  size: number;\n  blksize: number;\n  blocks: number;\n  atime: Date;\n  mtime: Date;\n  ctime: Date;\n  timestamp?: number;\n}\n\nexport interface IEmscriptenFSNode {\n  id: number;\n  name: string;\n  mode: number;\n  parent: IEmscriptenFSNode;\n  mount: { opts: { root: string } };\n  stream_ops: IEmscriptenStreamOps;\n  node_ops: IEmscriptenNodeOps;\n  timestamp: number;\n}\n\nexport interface IEmscriptenStream {\n  node: IEmscriptenFSNode;\n  nfd: any;\n  flags: string;\n  position: number;\n}\n\nexport interface IEmscriptenNodeOps {\n  getattr(node: IEmscriptenFSNode): IStats;\n  setattr(node: IEmscriptenFSNode, attr: IStats): void;\n  lookup(parent: IEmscriptenFSNode, name: string): IEmscriptenFSNode;\n  mknod(\n    parent: IEmscriptenFSNode,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode;\n  rename(oldNode: IEmscriptenFSNode, newDir: IEmscriptenFSNode, newName: string): void;\n  unlink(parent: IEmscriptenFSNode, name: string): void;\n  rmdir(parent: IEmscriptenFSNode, name: string): void;\n  readdir(node: IEmscriptenFSNode): string[];\n  symlink(parent: IEmscriptenFSNode, newName: string, oldPath: string): void;\n  readlink(node: IEmscriptenFSNode): string;\n}\n\nexport interface IEmscriptenStreamOps {\n  open(stream: IEmscriptenStream): void;\n  close(stream: IEmscriptenStream): void;\n  read(\n    stream: IEmscriptenStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number;\n  write(\n    stream: IEmscriptenStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number;\n  llseek(stream: IEmscriptenStream, offset: number, whence: number): number;\n}\n\n/**\n * The emscripten filesystem module API.\n */\nexport type FS = EmscriptenFS & {\n  ErrnoError: any;\n  createNode: (\n    parent: IEmscriptenFSNode | null,\n    name: string,\n    mode: number,\n    dev: number\n  ) => IEmscriptenFSNode;\n};\n\n/**\n * The emscripten filesystem error codes.\n */\nexport type ERRNO_CODES = any;\n\n/**\n * The emscripten FS Path API.\n */\nexport type PATH = {\n  basename: (path: string) => string;\n  dirname: (path: string) => string;\n  join: (...parts: string[]) => string;\n  join2: (l: string, r: string) => string;\n  normalize: (path: string) => string;\n  splitPath: (filename: string) => string;\n};\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nimport {\n  FS,\n  ERRNO_CODES,\n  PATH,\n  DIR_MODE,\n  SEEK_CUR,\n  SEEK_END,\n  IEmscriptenStream,\n  IEmscriptenStreamOps,\n  IEmscriptenNodeOps,\n  IEmscriptenFSNode,\n  IStats,\n} from './emscripten';\n\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\n\nexport const BLOCK_SIZE = 4096;\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n\nexport type TDriveMethod =\n  | 'readdir'\n  | 'rmdir'\n  | 'rename'\n  | 'getmode'\n  | 'lookup'\n  | 'mknod'\n  | 'getattr'\n  | 'get'\n  | 'put';\n\n/**\n * Interface of a request on the /api/drive endpoint\n */\nexport interface IDriveRequest {\n  /**\n   * The method of the request (rmdir, readdir etc)\n   */\n  method: TDriveMethod;\n\n  /**\n   * The path to the file/directory for which the request was sent\n   */\n  path: string;\n\n  /**\n   * Extra data on the request\n   */\n  data?: any;\n}\n\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite: { [flag: number]: boolean } = {\n  0 /*O_RDONLY*/: false,\n  1 /*O_WRONLY*/: true,\n  2 /*O_RDWR*/: true,\n  64 /*O_CREAT*/: true,\n  65 /*O_WRONLY|O_CREAT*/: true,\n  66 /*O_RDWR|O_CREAT*/: true,\n  129 /*O_WRONLY|O_EXCL*/: true,\n  193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n  514 /*O_RDWR|O_TRUNC*/: true,\n  577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n  578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n  705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n  706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n  1024 /*O_APPEND*/: true,\n  1025 /*O_WRONLY|O_APPEND*/: true,\n  1026 /*O_RDWR|O_APPEND*/: true,\n  1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n  1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n  1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n  1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n  1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n  1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n  4096 /*O_RDONLY|O_DSYNC*/: true,\n  4098 /*O_RDWR|O_DSYNC*/: true,\n};\n\n/** Implementation-specifc extension of an open stream, adding the file. */\nexport interface IDriveStream extends IEmscriptenStream {\n  file?: DriveFS.IFile;\n}\n\nexport class DriveFSEmscriptenStreamOps implements IEmscriptenStreamOps {\n  private fs: DriveFS;\n\n  constructor(fs: DriveFS) {\n    this.fs = fs;\n  }\n\n  open(stream: IDriveStream): void {\n    const path = this.fs.realPath(stream.node);\n    if (this.fs.FS.isFile(stream.node.mode)) {\n      stream.file = this.fs.API.get(path);\n    }\n  }\n\n  close(stream: IDriveStream): void {\n    if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n      return;\n    }\n\n    const path = this.fs.realPath(stream.node);\n\n    const flags = stream.flags;\n    let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n    parsedFlags &= 0x1fff;\n\n    let needsWrite = true;\n    if (parsedFlags in flagNeedsWrite) {\n      needsWrite = flagNeedsWrite[parsedFlags];\n    }\n\n    if (needsWrite) {\n      this.fs.API.put(path, stream.file);\n    }\n\n    stream.file = undefined;\n  }\n\n  read(\n    stream: IDriveStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number {\n    if (\n      length <= 0 ||\n      stream.file === undefined ||\n      position >= (stream.file.data.length || 0)\n    ) {\n      return 0;\n    }\n\n    const size = Math.min(stream.file.data.length - position, length);\n    buffer.set(stream.file.data.subarray(position, position + size), offset);\n    return size;\n  }\n\n  write(\n    stream: IDriveStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number {\n    if (length <= 0 || stream.file === undefined) {\n      return 0;\n    }\n\n    stream.node.timestamp = Date.now();\n\n    if (position + length > (stream.file?.data.length || 0)) {\n      const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n      stream.file.data = new Uint8Array(position + length);\n      stream.file.data.set(oldData);\n    }\n\n    stream.file.data.set(buffer.subarray(offset, offset + length), position);\n\n    return length;\n  }\n\n  llseek(stream: IDriveStream, offset: number, whence: number): number {\n    let position = offset;\n    if (whence === SEEK_CUR) {\n      position += stream.position;\n    } else if (whence === SEEK_END) {\n      if (this.fs.FS.isFile(stream.node.mode)) {\n        if (stream.file !== undefined) {\n          position += stream.file.data.length;\n        } else {\n          throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n        }\n      }\n    }\n\n    if (position < 0) {\n      throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n    }\n\n    return position;\n  }\n}\n\nexport class DriveFSEmscriptenNodeOps implements IEmscriptenNodeOps {\n  private fs: DriveFS;\n\n  constructor(fs: DriveFS) {\n    this.fs = fs;\n  }\n\n  getattr(node: IEmscriptenFSNode): IStats {\n    return {\n      ...this.fs.API.getattr(this.fs.realPath(node)),\n      mode: node.mode,\n      ino: node.id,\n    };\n  }\n\n  setattr(node: IEmscriptenFSNode, attr: IStats): void {\n    for (const [key, value] of Object.entries(attr)) {\n      switch (key) {\n        case 'mode':\n          node.mode = value;\n          break;\n        case 'timestamp':\n          node.timestamp = value;\n          break;\n        default:\n          console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n          break;\n      }\n    }\n  }\n\n  lookup(parent: IEmscriptenFSNode, name: string): IEmscriptenFSNode {\n    const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n    const result = this.fs.API.lookup(path);\n    if (!result.ok) {\n      throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n    }\n    return this.fs.createNode(parent, name, result.mode, 0);\n  }\n\n  mknod(\n    parent: IEmscriptenFSNode,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode {\n    const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n    this.fs.API.mknod(path, mode);\n    return this.fs.createNode(parent, name, mode, dev);\n  }\n\n  rename(oldNode: IEmscriptenFSNode, newDir: IEmscriptenFSNode, newName: string): void {\n    this.fs.API.rename(\n      oldNode.parent\n        ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n        : oldNode.name,\n      this.fs.PATH.join2(this.fs.realPath(newDir), newName)\n    );\n\n    // Updating the in-memory node\n    oldNode.name = newName;\n    oldNode.parent = newDir;\n  }\n\n  unlink(parent: IEmscriptenFSNode, name: string): void {\n    this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n  }\n\n  rmdir(parent: IEmscriptenFSNode, name: string) {\n    this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n  }\n\n  readdir(node: IEmscriptenFSNode): string[] {\n    return this.fs.API.readdir(this.fs.realPath(node));\n  }\n\n  symlink(parent: IEmscriptenFSNode, newName: string, oldPath: string): void {\n    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n  }\n\n  readlink(node: IEmscriptenFSNode): string {\n    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n  }\n}\n\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n  constructor(\n    baseUrl: string,\n    driveName: string,\n    mountpoint: string,\n    FS: FS,\n    ERRNO_CODES: ERRNO_CODES\n  ) {\n    this._baseUrl = baseUrl;\n    this._driveName = driveName;\n    this._mountpoint = mountpoint;\n    this.FS = FS;\n    this.ERRNO_CODES = ERRNO_CODES;\n  }\n\n  request(data: IDriveRequest): any {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', encodeURI(this.endpoint), false);\n\n    try {\n      xhr.send(JSON.stringify(data));\n    } catch (e) {\n      console.error(e);\n    }\n\n    if (xhr.status >= 400) {\n      throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n    }\n\n    return JSON.parse(xhr.responseText);\n  }\n\n  lookup(path: string): DriveFS.ILookup {\n    return this.request({ method: 'lookup', path: this.normalizePath(path) });\n  }\n\n  getmode(path: string): number {\n    return Number.parseInt(\n      this.request({ method: 'getmode', path: this.normalizePath(path) })\n    );\n  }\n\n  mknod(path: string, mode: number) {\n    return this.request({\n      method: 'mknod',\n      path: this.normalizePath(path),\n      data: { mode },\n    });\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    return this.request({\n      method: 'rename',\n      path: this.normalizePath(oldPath),\n      data: { newPath: this.normalizePath(newPath) },\n    });\n  }\n\n  readdir(path: string): string[] {\n    const dirlist = this.request({\n      method: 'readdir',\n      path: this.normalizePath(path),\n    });\n    dirlist.push('.');\n    dirlist.push('..');\n    return dirlist;\n  }\n\n  rmdir(path: string): void {\n    return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n  }\n\n  get(path: string): DriveFS.IFile {\n    const response = this.request({ method: 'get', path: this.normalizePath(path) });\n\n    const serializedContent = response.content;\n    const format: 'json' | 'text' | 'base64' | null = response.format;\n\n    switch (format) {\n      case 'json':\n      case 'text':\n        return {\n          data: encoder.encode(serializedContent),\n          format,\n        };\n      case 'base64': {\n        const binString = atob(serializedContent);\n        const len = binString.length;\n        const data = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          data[i] = binString.charCodeAt(i);\n        }\n        return {\n          data,\n          format,\n        };\n      }\n      default:\n        throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n    }\n  }\n\n  put(path: string, value: DriveFS.IFile) {\n    switch (value.format) {\n      case 'json':\n      case 'text':\n        return this.request({\n          method: 'put',\n          path: this.normalizePath(path),\n          data: {\n            format: value.format,\n            data: decoder.decode(value.data),\n          },\n        });\n      case 'base64': {\n        let binary = '';\n        for (let i = 0; i < value.data.byteLength; i++) {\n          binary += String.fromCharCode(value.data[i]);\n        }\n        return this.request({\n          method: 'put',\n          path: this.normalizePath(path),\n          data: {\n            format: value.format,\n            data: btoa(binary),\n          },\n        });\n      }\n    }\n  }\n\n  getattr(path: string): IStats {\n    const stats: IStats = this.request({\n      method: 'getattr',\n      path: this.normalizePath(path),\n    });\n    // Turn datetimes into proper objects\n    stats.atime = new Date(stats.atime);\n    stats.mtime = new Date(stats.mtime);\n    stats.ctime = new Date(stats.ctime);\n    // ensure a non-undefined size (0 isn't great, though)\n    stats.size = stats.size || 0;\n    return stats;\n  }\n\n  /**\n   * Normalize a Path by making it compliant for the content manager\n   *\n   * @param path: the path relatively to the Emscripten drive\n   */\n  normalizePath(path: string): string {\n    // Remove mountpoint prefix\n    if (path.startsWith(this._mountpoint)) {\n      path = path.slice(this._mountpoint.length);\n    }\n\n    // Add JupyterLab drive name\n    if (this._driveName) {\n      path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Get the api/drive endpoint\n   */\n  get endpoint(): string {\n    return `${this._baseUrl}api/drive`;\n  }\n\n  private _baseUrl: string;\n  private _driveName: string;\n  private _mountpoint: string;\n  private FS: FS;\n  private ERRNO_CODES: ERRNO_CODES;\n}\n\nexport class DriveFS {\n  FS: FS;\n  API: ContentsAPI;\n  PATH: PATH;\n  ERRNO_CODES: ERRNO_CODES;\n  driveName: string;\n\n  constructor(options: DriveFS.IOptions) {\n    this.FS = options.FS;\n    this.PATH = options.PATH;\n    this.ERRNO_CODES = options.ERRNO_CODES;\n    this.API = new ContentsAPI(\n      options.baseUrl,\n      options.driveName,\n      options.mountpoint,\n      this.FS,\n      this.ERRNO_CODES\n    );\n    this.driveName = options.driveName;\n\n    this.node_ops = new DriveFSEmscriptenNodeOps(this);\n    this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n  }\n\n  node_ops: IEmscriptenNodeOps;\n  stream_ops: IEmscriptenStreamOps;\n\n  mount(mount: any): IEmscriptenFSNode {\n    return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n  }\n\n  createNode(\n    parent: IEmscriptenFSNode | null,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode {\n    const FS = this.FS;\n    if (!FS.isDir(mode) && !FS.isFile(mode)) {\n      throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n    }\n    const node = FS.createNode(parent, name, mode, dev);\n    node.node_ops = this.node_ops;\n    node.stream_ops = this.stream_ops;\n    return node;\n  }\n\n  getMode(path: string): number {\n    return this.API.getmode(path);\n  }\n\n  realPath(node: IEmscriptenFSNode): string {\n    const parts: string[] = [];\n    let currentNode: IEmscriptenFSNode = node;\n\n    parts.push(currentNode.name);\n    while (currentNode.parent !== currentNode) {\n      currentNode = currentNode.parent;\n      parts.push(currentNode.name);\n    }\n    parts.reverse();\n\n    return this.PATH.join.apply(null, parts);\n  }\n}\n\n/**\n * A namespace for DriveFS configurations, etc.\n */\nexport namespace DriveFS {\n  /**\n   * A file representation;\n   */\n  export interface IFile {\n    data: Uint8Array;\n    format: 'json' | 'text' | 'base64';\n  }\n\n  /**\n   * The response to a lookup request;\n   */\n  export interface ILookup {\n    ok: boolean;\n    mode: number;\n  }\n\n  /**\n   * Initialization options for a drive;\n   */\n  export interface IOptions {\n    FS: FS;\n    PATH: PATH;\n    ERRNO_CODES: ERRNO_CODES;\n    baseUrl: string;\n    driveName: string;\n    mountpoint: string;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport { Contents as ServerContents, ContentsManager } from '@jupyterlab/services';\n\nimport { DIR_MODE, FILE_MODE } from './emscripten';\n\nimport { BLOCK_SIZE, IDriveRequest, DRIVE_API_PATH } from './drivefs';\n\nimport { IModel } from './contents';\n\nimport { IBroadcastChannelWrapper } from './tokens';\n\n/** A broadcaster for the ServiceWorker */\nexport class BroadcastChannelWrapper implements IBroadcastChannelWrapper {\n  public isDisposed = false;\n\n  constructor(options: BroadcastChannelWrapper.IOptions) {\n    this._contents = options.contents;\n  }\n\n  get enabled() {\n    return this._enabled;\n  }\n\n  enable() {\n    if (this._channel) {\n      console.warn('BroadcastChannel already created and enabled');\n      return;\n    }\n    this._channel = new BroadcastChannel(DRIVE_API_PATH);\n    this._channel.addEventListener('message', this._onMessage);\n    this._enabled = true;\n  }\n\n  disable() {\n    if (this._channel) {\n      this._channel.removeEventListener('message', this._onMessage);\n      this._channel = null;\n    }\n    this._enabled = false;\n  }\n\n  /** Clean up the broadcaster. */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.disable();\n    this.isDisposed = true;\n  }\n\n  /** Handle a message received on the BroadcastChannel */\n  protected _onMessage = async (event: MessageEvent<IDriveRequest>): Promise<void> => {\n    if (!this._channel) {\n      return;\n    }\n    const { _contents } = this;\n    const request = event.data;\n    const { path } = request;\n\n    // many successful responses default to null\n    let response: any = null;\n\n    // most requests will use a model\n    let model: ServerContents.IModel;\n\n    switch (request.method) {\n      case 'readdir':\n        model = await _contents.get(path, { content: true });\n        response = [];\n        if (model.type === 'directory' && model.content) {\n          response = model.content.map((subcontent: IModel) => subcontent.name);\n        }\n        break;\n      case 'rmdir':\n        await _contents.delete(path);\n        break;\n      case 'rename':\n        await _contents.rename(path, request.data.newPath);\n        break;\n      case 'getmode':\n        model = await _contents.get(path);\n        if (model.type === 'directory') {\n          response = DIR_MODE;\n        } else {\n          response = FILE_MODE;\n        }\n        break;\n      case 'lookup':\n        try {\n          model = await _contents.get(path);\n          response = {\n            ok: true,\n            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n          };\n        } catch (e) {\n          response = { ok: false };\n        }\n        break;\n      case 'mknod':\n        model = await _contents.newUntitled({\n          path: PathExt.dirname(path),\n          type: Number.parseInt(request.data.mode) === DIR_MODE ? 'directory' : 'file',\n          ext: PathExt.extname(path),\n        });\n        await _contents.rename(model.path, path);\n        break;\n      case 'getattr':\n        model = await _contents.get(path);\n\n        response = {\n          dev: 1,\n          nlink: 1,\n          uid: 0,\n          gid: 0,\n          rdev: 0,\n          size: model.size || 0,\n          blksize: BLOCK_SIZE,\n          blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),\n          atime: model.last_modified, // TODO Get the proper atime?\n          mtime: model.last_modified,\n          ctime: model.created,\n          timestamp: 0,\n        };\n        break;\n      case 'get':\n        model = await _contents.get(path, { content: true });\n\n        if (model.type === 'directory') {\n          break;\n        }\n\n        response = {\n          content:\n            model.format === 'json' ? JSON.stringify(model.content) : model.content,\n          format: model.format,\n        };\n        break;\n      case 'put':\n        await _contents.save(path, {\n          content:\n            request.data.format === 'json'\n              ? JSON.parse(request.data.data)\n              : request.data.data,\n          type: 'file',\n          format: request.data.format as ServerContents.FileFormat,\n        });\n        break;\n      default:\n        response = null as never;\n        break;\n    }\n\n    this._channel.postMessage(response);\n  };\n\n  protected _channel: BroadcastChannel | null = null;\n  protected _contents: ContentsManager;\n  protected _enabled = false;\n}\n\n/** A namespace for  */\nexport namespace BroadcastChannelWrapper {\n  export interface IOptions {\n    contents: ContentsManager;\n  }\n  export type TBroadcastResponse = any;\n}\n"],"names":["IContents","Token","MIME","FILE","JSON","PLAIN_TEXT","OCTET_STREAM","TYPES","parse","PageConfig","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","length","hasFormat","fileFormat","IBroadcastChannelWrapper","DEFAULT_STORAGE_NAME","Contents","constructor","options","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_storageName","_storageDrivers","this","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","async","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","name","createInstance","description","storeName","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","writable","counter","Private","EMPTY_NB","stringify","indexOf","key","setItem","toDir","slice","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","rename","URLExt","newUntitled","contentUnescaped","unescapeContent","atob","escape","slashed","toDelete","keys","filter","startsWith","Promise","all","map","forgetPath","copies","Boolean","push","splice","id","normalizeCheckpoint","toString","checkpointID","parseInt","includes","fileUrl","response","fetch","ok","headers","match","contentText","text","contentBytes","arrayBuffer","contentBuffer","Uint8Array","btoa","reduce","apiURL","json","err","console","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","DIR_MODE","FILE_MODE","SEEK_CUR","SEEK_END","DRIVE_SEPARATOR","DRIVE_API_PATH","BLOCK_SIZE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","open","stream","realPath","node","FS","isFile","mode","API","close","flags","parsedFlags","needsWrite","put","undefined","read","buffer","offset","position","Math","min","subarray","write","timestamp","now","oldData","llseek","whence","ErrnoError","ERRNO_CODES","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","ino","setattr","attr","value","entries","lookup","parent","PATH","join2","result","genericErrors","createNode","mknod","dev","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","xhr","XMLHttpRequest","encodeURI","endpoint","send","e","error","status","responseText","method","normalizePath","getmode","Number","newPath","dirlist","serializedContent","encode","binString","len","i","charCodeAt","decode","binary","byteLength","stats","atime","mtime","ctime","DriveFS","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","join","apply","BroadcastChannelWrapper","isDisposed","_onMessage","event","_channel","_contents","subcontent","delete","nlink","uid","gid","rdev","blksize","blocks","ceil","save","postMessage","_enabled","contents","enabled","enable","BroadcastChannel","addEventListener","disable","removeEventListener","dispose"],"sourceRoot":""}