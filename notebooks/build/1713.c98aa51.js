"use strict";(self.webpackChunk_JUPYTERLAB_CORE_OUTPUT=self.webpackChunk_JUPYTERLAB_CORE_OUTPUT||[]).push([[1713,3834],{33834:(e,t,n)=>{n.r(t),n.d(t,{LiteLicensesClient:()=>o,THIRD_PARTY_LICENSES:()=>i});var s=n(51377),a=n(64649);const i="third-party-licenses.json",r=Object.freeze({packages:[]});class o extends s.Licenses.LicensesClient{async getBundles(){return{bundles:{...await this._getFederated(),[this.appName]:await this._getAppLicenses()}}}async getDownloadLink(e){const t=await this.getBundles(),n=JSON.stringify(t,null,2),s="json"===e.format?"application/json":"text/plain",a=new Blob([n],{type:s});return URL.createObjectURL(a)}get appName(){return a.PageConfig.getOption("appName")||"JupyterLite"}get appLicensesUrl(){return a.URLExt.join(a.PageConfig.getBaseUrl(),"build",i)}get labExtensionsUrl(){return a.PageConfig.getOption("fullLabextensionsUrl")}async _getAppLicenses(){let e=r;try{e=(await fetch(this.appLicensesUrl)).json()}catch(e){console.warn("Could not resolve licenses for",this.appName)}return e}async _getFederated(){const e={};let t;try{t=JSON.parse(a.PageConfig.getOption("federated_extensions"))}catch{return e}const n=[];for(const s of t)n.push(this._getOneFederated(s,e));try{await Promise.all(n)}catch(e){console.warn("Error resolving licenses",e)}return e}async _getOneFederated(e,t){try{const n=a.URLExt.join(this.labExtensionsUrl,e.name,"static",i),s=await fetch(n);t[e.name]=await s.json()}catch{console.warn("Could not resolve licenses for",e),t[e.name]=r}}}}}]);
//# sourceMappingURL=1713.c98aa51.js.map