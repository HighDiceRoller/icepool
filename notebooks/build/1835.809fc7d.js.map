{"version":3,"file":"1835.809fc7d.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module docmanager-extension\n */\nimport { ILabShell, ILabStatus } from '@jupyterlab/application';\nimport { addCommandToolbarButtonClass, CommandToolbarButtonComponent, Dialog, ICommandPalette, InputDialog, ISessionContextDialogs, ReactWidget, showDialog, showErrorMessage, UseSignal } from '@jupyterlab/apputils';\nimport { PathExt, Time } from '@jupyterlab/coreutils';\nimport { DocumentManager, IDocumentManager, PathStatus, renameDialog, SavingStatus } from '@jupyterlab/docmanager';\nimport { IDocumentProviderFactory } from '@jupyterlab/docprovider';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IStatusBar } from '@jupyterlab/statusbar';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { saveIcon } from '@jupyterlab/ui-components';\nimport { each, map, some, toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Widget } from '@lumino/widgets';\nimport * as React from 'react';\n/**\n * The command IDs used by the document manager plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.clone = 'docmanager:clone';\n    CommandIDs.deleteFile = 'docmanager:delete-file';\n    CommandIDs.newUntitled = 'docmanager:new-untitled';\n    CommandIDs.open = 'docmanager:open';\n    CommandIDs.openBrowserTab = 'docmanager:open-browser-tab';\n    CommandIDs.reload = 'docmanager:reload';\n    CommandIDs.rename = 'docmanager:rename';\n    CommandIDs.del = 'docmanager:delete';\n    CommandIDs.restoreCheckpoint = 'docmanager:restore-checkpoint';\n    CommandIDs.save = 'docmanager:save';\n    CommandIDs.saveAll = 'docmanager:save-all';\n    CommandIDs.saveAs = 'docmanager:save-as';\n    CommandIDs.download = 'docmanager:download';\n    CommandIDs.toggleAutosave = 'docmanager:toggle-autosave';\n    CommandIDs.showInFileBrowser = 'docmanager:show-in-file-browser';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The id of the document manager plugin.\n */\nconst docManagerPluginId = '@jupyterlab/docmanager-extension:plugin';\n/**\n * The default document manager provider.\n */\nconst docManagerPlugin = {\n    id: docManagerPluginId,\n    provides: IDocumentManager,\n    requires: [ISettingRegistry, ITranslator],\n    optional: [\n        ILabStatus,\n        ICommandPalette,\n        ILabShell,\n        ISessionContextDialogs,\n        IDocumentProviderFactory\n    ],\n    activate: (app, settingRegistry, translator, status, palette, labShell, sessionDialogs, docProviderFactory) => {\n        var _a;\n        const trans = translator.load('jupyterlab');\n        const manager = app.serviceManager;\n        const contexts = new WeakSet();\n        const opener = {\n            open: (widget, options) => {\n                if (!widget.id) {\n                    widget.id = `document-manager-${++Private.id}`;\n                }\n                widget.title.dataset = Object.assign({ type: 'document-title' }, widget.title.dataset);\n                if (!widget.isAttached) {\n                    app.shell.add(widget, 'main', options || {});\n                }\n                app.shell.activateById(widget.id);\n                // Handle dirty state for open documents.\n                const context = docManager.contextForWidget(widget);\n                if (context && !contexts.has(context)) {\n                    if (status) {\n                        handleContext(status, context);\n                    }\n                    contexts.add(context);\n                }\n            }\n        };\n        const registry = app.docRegistry;\n        const when = app.restored.then(() => void 0);\n        const docManager = new DocumentManager({\n            registry,\n            manager,\n            opener,\n            when,\n            setBusy: (_a = (status && (() => status.setBusy()))) !== null && _a !== void 0 ? _a : undefined,\n            sessionDialogs: sessionDialogs || undefined,\n            translator,\n            collaborative: true,\n            docProviderFactory: docProviderFactory !== null && docProviderFactory !== void 0 ? docProviderFactory : undefined\n        });\n        // Register the file operations commands.\n        addCommands(app, docManager, opener, settingRegistry, translator, labShell, palette);\n        // Keep up to date with the settings registry.\n        const onSettingsUpdated = (settings) => {\n            // Handle whether to autosave\n            const autosave = settings.get('autosave').composite;\n            docManager.autosave =\n                autosave === true || autosave === false ? autosave : true;\n            app.commands.notifyCommandChanged(CommandIDs.toggleAutosave);\n            // Handle autosave interval\n            const autosaveInterval = settings.get('autosaveInterval').composite;\n            docManager.autosaveInterval = autosaveInterval || 120;\n            // Handle last modified timestamp check margin\n            const lastModifiedCheckMargin = settings.get('lastModifiedCheckMargin')\n                .composite;\n            docManager.lastModifiedCheckMargin = lastModifiedCheckMargin || 500;\n            const renameUntitledFile = settings.get('renameUntitledFileOnSave')\n                .composite;\n            docManager.renameUntitledFileOnSave = renameUntitledFile !== null && renameUntitledFile !== void 0 ? renameUntitledFile : true;\n            // Handle default widget factory overrides.\n            const defaultViewers = settings.get('defaultViewers').composite;\n            const overrides = {};\n            // Filter the defaultViewers and file types for existing ones.\n            Object.keys(defaultViewers).forEach(ft => {\n                if (!registry.getFileType(ft)) {\n                    console.warn(`File Type ${ft} not found`);\n                    return;\n                }\n                if (!registry.getWidgetFactory(defaultViewers[ft])) {\n                    console.warn(`Document viewer ${defaultViewers[ft]} not found`);\n                }\n                overrides[ft] = defaultViewers[ft];\n            });\n            // Set the default factory overrides. If not provided, this has the\n            // effect of unsetting any previous overrides.\n            each(registry.fileTypes(), ft => {\n                try {\n                    registry.setDefaultWidgetFactory(ft.name, overrides[ft.name]);\n                }\n                catch (_a) {\n                    console.warn(`Failed to set default viewer ${overrides[ft.name]} for file type ${ft.name}`);\n                }\n            });\n        };\n        // Fetch the initial state of the settings.\n        Promise.all([settingRegistry.load(docManagerPluginId), app.restored])\n            .then(([settings]) => {\n            settings.changed.connect(onSettingsUpdated);\n            onSettingsUpdated(settings);\n        })\n            .catch((reason) => {\n            console.error(reason.message);\n        });\n        // Register a fetch transformer for the settings registry,\n        // allowing us to dynamically populate a help string with the\n        // available document viewers and file types for the default\n        // viewer overrides.\n        settingRegistry.transform(docManagerPluginId, {\n            fetch: plugin => {\n                // Get the available file types.\n                const fileTypes = toArray(registry.fileTypes())\n                    .map(ft => ft.name)\n                    .join('    \\n');\n                // Get the available widget factories.\n                const factories = toArray(registry.widgetFactories())\n                    .map(f => f.name)\n                    .join('    \\n');\n                // Generate the help string.\n                const description = trans.__(`Overrides for the default viewers for file types.\nSpecify a mapping from file type name to document viewer name, for example:\n\ndefaultViewers: {\n  markdown: \"Markdown Preview\"\n}\n\nIf you specify non-existent file types or viewers, or if a viewer cannot\nopen a given file type, the override will not function.\n\nAvailable viewers:\n%1\n\nAvailable file types:\n%2`, factories, fileTypes);\n                const schema = JSONExt.deepCopy(plugin.schema);\n                schema.properties.defaultViewers.description = description;\n                return Object.assign(Object.assign({}, plugin), { schema });\n            }\n        });\n        // If the document registry gains or loses a factory or file type,\n        // regenerate the settings description with the available options.\n        registry.changed.connect(() => settingRegistry.reload(docManagerPluginId));\n        return docManager;\n    }\n};\n/**\n * A plugin for adding a saving status item to the status bar.\n */\nexport const savingStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:saving-status',\n    autoStart: true,\n    requires: [IDocumentManager, ILabShell, ITranslator],\n    optional: [IStatusBar],\n    activate: (_, docManager, labShell, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const saving = new SavingStatus({ docManager, translator });\n        // Keep the currently active widget synchronized.\n        saving.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            saving.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(savingStatusPlugin.id, {\n            item: saving,\n            align: 'middle',\n            isActive: () => saving.model !== null && saving.model.status !== null,\n            activeStateChanged: saving.model.stateChanged\n        });\n    }\n};\n/**\n * A plugin providing a file path widget to the status bar.\n */\nexport const pathStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:path-status',\n    autoStart: true,\n    requires: [IDocumentManager, ILabShell],\n    optional: [IStatusBar],\n    activate: (_, docManager, labShell, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const path = new PathStatus({ docManager });\n        // Keep the file path widget up-to-date with the application active widget.\n        path.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            path.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(pathStatusPlugin.id, {\n            item: path,\n            align: 'right',\n            rank: 0\n        });\n    }\n};\n/**\n * A plugin providing download commands in the file menu and command palette.\n */\nexport const downloadPlugin = {\n    id: '@jupyterlab/docmanager-extension:download',\n    autoStart: true,\n    requires: [ITranslator, IDocumentManager],\n    optional: [ICommandPalette],\n    activate: (app, translator, docManager, palette) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const isEnabled = () => {\n            const { currentWidget } = shell;\n            return !!(currentWidget && docManager.contextForWidget(currentWidget));\n        };\n        commands.addCommand(CommandIDs.download, {\n            label: trans.__('Download'),\n            caption: trans.__('Download the file to your computer'),\n            isEnabled,\n            execute: () => {\n                // Checks that shell.currentWidget is valid:\n                if (isEnabled()) {\n                    const context = docManager.contextForWidget(shell.currentWidget);\n                    if (!context) {\n                        return showDialog({\n                            title: trans.__('Cannot Download'),\n                            body: trans.__('No context found for current widget!'),\n                            buttons: [Dialog.okButton({ label: trans.__('OK') })]\n                        });\n                    }\n                    return context.download();\n                }\n            }\n        });\n        const category = trans.__('File Operations');\n        if (palette) {\n            palette.addItem({ command: CommandIDs.download, category });\n        }\n    }\n};\n/**\n * A plugin providing open-browser-tab commands.\n *\n * This is its own plugin in case you would like to disable this feature.\n * e.g. jupyter labextension disable @jupyterlab/docmanager-extension:open-browser-tab\n *\n * Note: If disabling this, you may also want to disable:\n * @jupyterlab/filebrowser-extension:open-browser-tab\n */\nexport const openBrowserTabPlugin = {\n    id: '@jupyterlab/docmanager-extension:open-browser-tab',\n    autoStart: true,\n    requires: [ITranslator, IDocumentManager],\n    activate: (app, translator, docManager) => {\n        const trans = translator.load('jupyterlab');\n        const { commands } = app;\n        commands.addCommand(CommandIDs.openBrowserTab, {\n            execute: args => {\n                const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n                if (!path) {\n                    return;\n                }\n                return docManager.services.contents.getDownloadUrl(path).then(url => {\n                    const opened = window.open();\n                    if (opened) {\n                        opened.opener = null;\n                        opened.location.href = url;\n                    }\n                    else {\n                        throw new Error('Failed to open new browser tab.');\n                    }\n                });\n            },\n            icon: args => args['icon'] || '',\n            label: () => trans.__('Open in New Browser Tab')\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    docManagerPlugin,\n    pathStatusPlugin,\n    savingStatusPlugin,\n    downloadPlugin,\n    openBrowserTabPlugin\n];\nexport default plugins;\n/**\n * Toolbar item factory\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     *\n     */\n    function createSaveButton(commands, fileChanged) {\n        return addCommandToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: fileChanged }, () => (React.createElement(CommandToolbarButtonComponent, { commands: commands, id: CommandIDs.save, label: '', args: { toolbar: true } })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n})(ToolbarItems || (ToolbarItems = {}));\n/* Widget to display the revert to checkpoint confirmation. */\nclass RevertConfirmWidget extends Widget {\n    /**\n     * Construct a new revert confirmation widget.\n     */\n    constructor(checkpoint, trans, fileType = 'notebook') {\n        super({\n            node: Private.createRevertConfirmNode(checkpoint, fileType, trans)\n        });\n    }\n}\n// Returns the file type for a widget.\nfunction fileType(widget, docManager) {\n    if (!widget) {\n        return 'File';\n    }\n    const context = docManager.contextForWidget(widget);\n    if (!context) {\n        return '';\n    }\n    const fts = docManager.registry.getFileTypesForPath(context.path);\n    return fts.length && fts[0].displayName ? fts[0].displayName : 'File';\n}\n/**\n * Add the file operations commands to the application's command registry.\n */\nfunction addCommands(app, docManager, opener, settingRegistry, translator, labShell, palette) {\n    const trans = translator.load('jupyterlab');\n    const { commands, shell } = app;\n    const category = trans.__('File Operations');\n    const isEnabled = () => {\n        const { currentWidget } = shell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    const isWritable = () => {\n        const { currentWidget } = shell;\n        if (!currentWidget) {\n            return false;\n        }\n        const context = docManager.contextForWidget(currentWidget);\n        return !!(context &&\n            context.contentsModel &&\n            context.contentsModel.writable);\n    };\n    // If inside a rich application like JupyterLab, add additional functionality.\n    if (labShell) {\n        addLabCommands(app, docManager, labShell, opener, translator);\n    }\n    commands.addCommand(CommandIDs.deleteFile, {\n        label: () => `Delete ${fileType(shell.currentWidget, docManager)}`,\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            if (!path) {\n                const command = CommandIDs.deleteFile;\n                throw new Error(`A non-empty path is required for ${command}.`);\n            }\n            return docManager.deleteFile(path);\n        }\n    });\n    commands.addCommand(CommandIDs.newUntitled, {\n        execute: args => {\n            // FIXME-TRANS: Localizing args['error']?\n            const errorTitle = args['error'] || trans.__('Error');\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const options = {\n                type: args['type'],\n                path\n            };\n            if (args['type'] === 'file') {\n                options.ext = args['ext'] || '.txt';\n            }\n            return docManager.services.contents\n                .newUntitled(options)\n                .catch(error => showErrorMessage(errorTitle, error));\n        },\n        label: args => args['label'] || `New ${args['type']}`\n    });\n    commands.addCommand(CommandIDs.open, {\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const factory = args['factory'] || void 0;\n            const kernel = args === null || args === void 0 ? void 0 : args.kernel;\n            const options = args['options'] || void 0;\n            return docManager.services.contents\n                .get(path, { content: false })\n                .then(() => docManager.openOrReveal(path, factory, kernel, options));\n        },\n        icon: args => args['icon'] || '',\n        label: args => (args['label'] || args['factory']),\n        mnemonic: args => args['mnemonic'] || -1\n    });\n    commands.addCommand(CommandIDs.reload, {\n        label: () => trans.__('Reload %1 from Disk', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Reload contents from disk'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            const type = fileType(shell.currentWidget, docManager);\n            if (!context) {\n                return showDialog({\n                    title: trans.__('Cannot Reload'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            if (context.model.dirty) {\n                return showDialog({\n                    title: trans.__('Reload %1 from Disk', type),\n                    body: trans.__('Are you sure you want to reload the %1 from the disk?', type),\n                    buttons: [\n                        Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        Dialog.warnButton({ label: trans.__('Reload') })\n                    ]\n                }).then(result => {\n                    if (result.button.accept && !context.isDisposed) {\n                        return context.revert();\n                    }\n                });\n            }\n            else {\n                if (!context.isDisposed) {\n                    return context.revert();\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.restoreCheckpoint, {\n        label: () => trans.__('Revert %1 to Checkpoint', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Revert contents to previous checkpoint'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            if (!context) {\n                return showDialog({\n                    title: trans.__('Cannot Revert'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            return context.listCheckpoints().then(checkpoints => {\n                if (checkpoints.length < 1) {\n                    return;\n                }\n                const lastCheckpoint = checkpoints[checkpoints.length - 1];\n                if (!lastCheckpoint) {\n                    return;\n                }\n                const type = fileType(shell.currentWidget, docManager);\n                return showDialog({\n                    title: trans.__('Revert %1 to checkpoint', type),\n                    body: new RevertConfirmWidget(lastCheckpoint, trans, type),\n                    buttons: [\n                        Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        Dialog.warnButton({ label: trans.__('Revert') })\n                    ]\n                }).then(result => {\n                    if (context.isDisposed) {\n                        return;\n                    }\n                    if (result.button.accept) {\n                        if (context.model.readOnly) {\n                            return context.revert();\n                        }\n                        return context.restoreCheckpoint().then(() => context.revert());\n                    }\n                });\n            });\n        }\n    });\n    const saveInProgress = new WeakSet();\n    commands.addCommand(CommandIDs.save, {\n        label: () => trans.__('Save %1', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Save and create checkpoint'),\n        icon: args => (args.toolbar ? saveIcon : ''),\n        isEnabled: isWritable,\n        execute: async () => {\n            var _a, _b, _c;\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const widget = shell.currentWidget;\n                const context = docManager.contextForWidget(widget);\n                if (!context) {\n                    return showDialog({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                    });\n                }\n                else {\n                    if (saveInProgress.has(context)) {\n                        return;\n                    }\n                    if (context.model.readOnly) {\n                        return showDialog({\n                            title: trans.__('Cannot Save'),\n                            body: trans.__('Document is read-only'),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                    }\n                    saveInProgress.add(context);\n                    const oldName = PathExt.basename((_b = (_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '');\n                    let newName = oldName;\n                    if (docManager.renameUntitledFileOnSave &&\n                        widget.isUntitled === true) {\n                        const result = await InputDialog.getText({\n                            title: trans.__('Rename file'),\n                            okLabel: trans.__('Rename'),\n                            placeholder: trans.__('File name'),\n                            text: oldName,\n                            selectionRange: oldName.length - PathExt.extname(oldName).length,\n                            checkbox: {\n                                label: trans.__(\"Don't ask me again.\"),\n                                caption: trans.__('If checked, you will not be asked to rename future untitled files when saving them.')\n                            }\n                        });\n                        if (result.button.accept) {\n                            newName = (_c = result.value) !== null && _c !== void 0 ? _c : oldName;\n                            widget.isUntitled = false;\n                            if (typeof result.isChecked === 'boolean') {\n                                const currentSetting = (await settingRegistry.get(docManagerPluginId, 'renameUntitledFileOnSave')).composite;\n                                if (result.isChecked === currentSetting) {\n                                    settingRegistry\n                                        .set(docManagerPluginId, 'renameUntitledFileOnSave', !result.isChecked)\n                                        .catch(reason => {\n                                        console.error(`Fail to set 'renameUntitledFileOnSave:\\n${reason}`);\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    try {\n                        await context.save();\n                        if (!(widget === null || widget === void 0 ? void 0 : widget.isDisposed)) {\n                            return context.createCheckpoint();\n                        }\n                    }\n                    catch (err) {\n                        // If the save was canceled by user-action, do nothing.\n                        if (err.name === 'ModalCancelError') {\n                            return;\n                        }\n                        throw err;\n                    }\n                    finally {\n                        saveInProgress.delete(context);\n                        if (newName !== oldName) {\n                            await context.rename(newName);\n                        }\n                    }\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.saveAll, {\n        label: () => trans.__('Save All'),\n        caption: trans.__('Save all open documents'),\n        isEnabled: () => {\n            return some(map(shell.widgets('main'), w => docManager.contextForWidget(w)), c => { var _a, _b; return (_b = (_a = c === null || c === void 0 ? void 0 : c.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) !== null && _b !== void 0 ? _b : false; });\n        },\n        execute: () => {\n            const promises = [];\n            const paths = new Set(); // Cache so we don't double save files.\n            each(shell.widgets('main'), widget => {\n                const context = docManager.contextForWidget(widget);\n                if (context && !context.model.readOnly && !paths.has(context.path)) {\n                    paths.add(context.path);\n                    promises.push(context.save());\n                }\n            });\n            return Promise.all(promises);\n        }\n    });\n    commands.addCommand(CommandIDs.saveAs, {\n        label: () => trans.__('Save %1 As…', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Save with new path'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(shell.currentWidget);\n                if (!context) {\n                    return showDialog({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                    });\n                }\n                return context.saveAs();\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleAutosave, {\n        label: trans.__('Autosave Documents'),\n        isToggled: () => docManager.autosave,\n        execute: () => {\n            const value = !docManager.autosave;\n            const key = 'autosave';\n            return settingRegistry\n                .set(docManagerPluginId, key, value)\n                .catch((reason) => {\n                console.error(`Failed to set ${docManagerPluginId}:${key} - ${reason.message}`);\n            });\n        }\n    });\n    if (palette) {\n        [\n            CommandIDs.reload,\n            CommandIDs.restoreCheckpoint,\n            CommandIDs.save,\n            CommandIDs.saveAs,\n            CommandIDs.toggleAutosave\n        ].forEach(command => {\n            palette.addItem({ command, category });\n        });\n    }\n}\nfunction addLabCommands(app, docManager, labShell, opener, translator) {\n    const trans = translator.load('jupyterlab');\n    const { commands } = app;\n    // Returns the doc widget associated with the most recent contextmenu event.\n    const contextMenuWidget = () => {\n        var _a;\n        const pathRe = /[Pp]ath:\\s?(.*)\\n?/;\n        const test = (node) => { var _a; return !!((_a = node['title']) === null || _a === void 0 ? void 0 : _a.match(pathRe)); };\n        const node = app.contextMenuHitTest(test);\n        const pathMatch = node === null || node === void 0 ? void 0 : node['title'].match(pathRe);\n        return ((_a = (pathMatch && docManager.findWidget(pathMatch[1], null))) !== null && _a !== void 0 ? _a : \n        // Fall back to active doc widget if path cannot be obtained from event.\n        labShell.currentWidget);\n    };\n    // Returns `true` if the current widget has a document context.\n    const isEnabled = () => {\n        const { currentWidget } = labShell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    commands.addCommand(CommandIDs.clone, {\n        label: () => trans.__('New View for %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: args => {\n            const widget = contextMenuWidget();\n            const options = args['options'] || {\n                mode: 'split-right'\n            };\n            if (!widget) {\n                return;\n            }\n            // Clone the widget.\n            const child = docManager.cloneWidget(widget);\n            if (child) {\n                opener.open(child, options);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.rename, {\n        label: () => {\n            let t = fileType(contextMenuWidget(), docManager);\n            if (t) {\n                t = ' ' + t;\n            }\n            return trans.__('Rename%1…', t);\n        },\n        isEnabled,\n        execute: () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                return renameDialog(docManager, context.path);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.del, {\n        label: () => trans.__('Delete %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: async () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                if (!context) {\n                    return;\n                }\n                const result = await showDialog({\n                    title: trans.__('Delete'),\n                    body: trans.__('Are you sure you want to delete %1', context.path),\n                    buttons: [\n                        Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        Dialog.warnButton({ label: trans.__('Delete') })\n                    ]\n                });\n                if (result.button.accept) {\n                    await app.commands.execute('docmanager:delete-file', {\n                        path: context.path\n                    });\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.showInFileBrowser, {\n        label: () => trans.__('Show in File Browser'),\n        isEnabled,\n        execute: async () => {\n            const widget = contextMenuWidget();\n            const context = widget && docManager.contextForWidget(widget);\n            if (!context) {\n                return;\n            }\n            // 'activate' is needed if this command is selected in the \"open tabs\" sidebar\n            await commands.execute('filebrowser:activate', { path: context.path });\n            await commands.execute('filebrowser:go-to-path', { path: context.path });\n        }\n    });\n}\n/**\n * Handle dirty state for a context.\n */\nfunction handleContext(status, context) {\n    let disposable = null;\n    const onStateChanged = (sender, args) => {\n        if (args.name === 'dirty') {\n            if (args.newValue === true) {\n                if (!disposable) {\n                    disposable = status.setDirty();\n                }\n            }\n            else if (disposable) {\n                disposable.dispose();\n                disposable = null;\n            }\n        }\n    };\n    void context.ready.then(() => {\n        context.model.stateChanged.connect(onStateChanged);\n        if (context.model.dirty) {\n            disposable = status.setDirty();\n        }\n    });\n    context.disposed.connect(() => {\n        if (disposable) {\n            disposable.dispose();\n        }\n    });\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A counter for unique IDs.\n     */\n    Private.id = 0;\n    function createRevertConfirmNode(checkpoint, fileType, trans) {\n        const body = document.createElement('div');\n        const confirmMessage = document.createElement('p');\n        const confirmText = document.createTextNode(trans.__('Are you sure you want to revert the %1 to the latest checkpoint? ', fileType));\n        const cannotUndoText = document.createElement('strong');\n        cannotUndoText.textContent = trans.__('This cannot be undone.');\n        confirmMessage.appendChild(confirmText);\n        confirmMessage.appendChild(cannotUndoText);\n        const lastCheckpointMessage = document.createElement('p');\n        const lastCheckpointText = document.createTextNode(trans.__('The checkpoint was last updated at: '));\n        const lastCheckpointDate = document.createElement('p');\n        const date = new Date(checkpoint.last_modified);\n        lastCheckpointDate.style.textAlign = 'center';\n        lastCheckpointDate.textContent =\n            Time.format(date, 'dddd, MMMM Do YYYY, h:mm:ss a') +\n                ' (' +\n                Time.formatHuman(date) +\n                ')';\n        lastCheckpointMessage.appendChild(lastCheckpointText);\n        lastCheckpointMessage.appendChild(lastCheckpointDate);\n        body.appendChild(confirmMessage);\n        body.appendChild(lastCheckpointMessage);\n        return body;\n    }\n    Private.createRevertConfirmNode = createRevertConfirmNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":["CommandIDs","clone","deleteFile","newUntitled","open","openBrowserTab","reload","rename","del","restoreCheckpoint","save","saveAll","saveAs","download","toggleAutosave","showInFileBrowser","docManagerPluginId","docManagerPlugin","id","provides","IDocumentManager","requires","ISettingRegistry","ITranslator","optional","ILabStatus","ICommandPalette","ILabShell","ISessionContextDialogs","IDocumentProviderFactory","activate","app","settingRegistry","translator","status","palette","labShell","sessionDialogs","docProviderFactory","_a","trans","load","manager","serviceManager","contexts","WeakSet","opener","widget","options","Private","title","dataset","Object","assign","type","isAttached","shell","add","activateById","context","docManager","contextForWidget","has","disposable","onStateChanged","sender","args","name","newValue","setDirty","dispose","ready","then","model","stateChanged","connect","dirty","disposed","handleContext","registry","docRegistry","when","restored","DocumentManager","setBusy","undefined","collaborative","commands","category","__","isEnabled","currentWidget","contextMenuWidget","pathRe","node","contextMenuHitTest","match","pathMatch","findWidget","addCommand","label","fileType","execute","mode","child","cloneWidget","t","renameDialog","path","async","showDialog","body","buttons","Dialog","button","accept","addLabCommands","command","Error","errorTitle","ext","services","contents","catch","error","showErrorMessage","factory","kernel","get","content","openOrReveal","icon","mnemonic","caption","result","isDisposed","revert","listCheckpoints","checkpoints","length","lastCheckpoint","RevertConfirmWidget","readOnly","saveInProgress","toolbar","saveIcon","contentsModel","writable","_b","_c","oldName","PathExt","newName","renameUntitledFileOnSave","isUntitled","InputDialog","okLabel","placeholder","text","selectionRange","checkbox","value","isChecked","currentSetting","composite","set","reason","console","createCheckpoint","err","delete","some","map","widgets","w","c","promises","paths","Set","each","push","Promise","all","isToggled","autosave","key","message","forEach","addItem","addCommands","onSettingsUpdated","settings","notifyCommandChanged","autosaveInterval","lastModifiedCheckMargin","renameUntitledFile","defaultViewers","overrides","keys","ft","getFileType","getWidgetFactory","warn","fileTypes","setDefaultWidgetFactory","changed","transform","fetch","plugin","toArray","join","factories","widgetFactories","f","description","schema","JSONExt","properties","savingStatusPlugin","autoStart","IStatusBar","_","statusBar","saving","SavingStatus","currentChanged","registerStatusItem","item","align","isActive","activeStateChanged","pathStatusPlugin","PathStatus","rank","downloadPlugin","openBrowserTabPlugin","getDownloadUrl","url","opened","window","location","href","ToolbarItems","createSaveButton","fileChanged","addCommandToolbarButtonClass","ReactWidget","UseSignal","signal","CommandToolbarButtonComponent","Widget","constructor","checkpoint","super","createRevertConfirmNode","fts","getFileTypesForPath","displayName","document","createElement","confirmMessage","confirmText","createTextNode","cannotUndoText","textContent","appendChild","lastCheckpointMessage","lastCheckpointText","lastCheckpointDate","date","Date","last_modified","style","textAlign","Time"],"sourceRoot":""}