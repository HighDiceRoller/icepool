{"version":3,"file":"1713.c98aa51.js","mappings":"sOAQO,MAAMA,EAAuB,4BAI9BC,EAAeC,OAAOC,OAAO,CAAEC,SAAU,KAIxC,MAAMC,UAA2B,EAAAC,SAASC,eAI7C,gBAAMC,GACF,MAAO,CACHC,QAAS,UACKC,KAAKC,gBACf,CAACD,KAAKE,eAAgBF,KAAKG,mBAGvC,CAMA,qBAAMC,CAAgBC,GAClB,MAAMN,QAAgBC,KAAKF,aACrBQ,EAAOC,KAAKC,UAAUT,EAAS,KAAM,GAErCU,EAA0B,SAAnBJ,EAAQK,OAAoB,mBAAqB,aACxDC,EAAO,IAAIC,KAAK,CAACN,GAAO,CAAEO,KAAMJ,IAEtC,OAAOK,IAAIC,gBAAgBJ,EAC/B,CAIA,WAAIT,GACA,OAAO,EAAAc,WAAWC,UAAU,YAAc,aAC9C,CAIA,kBAAIC,GACA,OAAO,EAAAC,OAAOC,KAAK,EAAAJ,WAAWK,aAAc,QAAS/B,EACzD,CAIA,oBAAIgC,GACA,OAAO,EAAAN,WAAWC,UAAU,uBAChC,CAIA,qBAAMd,GACF,IAAIoB,EAAShC,EACb,IAEIgC,SADuBC,MAAMxB,KAAKkB,iBAChBO,MACtB,CACA,MAAOC,GACHC,QAAQC,KAAK,iCAAkC5B,KAAKE,QACxD,CACA,OAAOqB,CACX,CAIA,mBAAMtB,GACF,MAAMF,EAAU,CAAC,EACjB,IAAI8B,EACJ,IACIA,EAAYtB,KAAKuB,MAAM,EAAAd,WAAWC,UAAU,wBAChD,CACA,MACI,OAAOlB,CACX,CACA,MAAMgC,EAAW,GACjB,IAAK,MAAMC,KAAOH,EACdE,EAASE,KAAKjC,KAAKkC,iBAAiBF,EAAKjC,IAE7C,UACUoC,QAAQC,IAAIL,EACtB,CACA,MAAOL,GACHC,QAAQC,KAAK,2BAA4BF,EAC7C,CACA,OAAO3B,CACX,CAIA,sBAAMmC,CAAiBF,EAAKjC,GACxB,IACI,MAAMsC,EAAM,EAAAlB,OAAOC,KAAKpB,KAAKsB,iBAAkBU,EAAIM,KAAM,SAAUhD,GAC7DiD,QAAiBf,MAAMa,GAC7BtC,EAAQiC,EAAIM,YAAcC,EAASd,MACvC,CACA,MACIE,QAAQC,KAAK,iCAAkCI,GAC/CjC,EAAQiC,EAAIM,MAAQ/C,CACxB,CACJ,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/lib/licenses.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Licenses } from '@jupyterlab/apputils';\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class LiteLicensesClient extends Licenses.LicensesClient {\n    /**\n     * A GET handler for the licenses\n     */\n    async getBundles() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Get the download link for the requested format\n     *\n     * TODO: update to download after https://github.com/jupyterlab/jupyterlab/pull/17397 is released.\n     */\n    async getDownloadLink(options) {\n        const bundles = await this.getBundles();\n        const data = JSON.stringify(bundles, null, 2);\n        // Create a blob with the appropriate MIME type\n        const mime = options.format === 'json' ? 'application/json' : 'text/plain';\n        const blob = new Blob([data], { type: mime });\n        // Generate a URL for the blob\n        return URL.createObjectURL(blob);\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map"],"names":["THIRD_PARTY_LICENSES","EMPTY_BUNDLE","Object","freeze","packages","LiteLicensesClient","Licenses","LicensesClient","getBundles","bundles","this","_getFederated","appName","_getAppLicenses","getDownloadLink","options","data","JSON","stringify","mime","format","blob","Blob","type","URL","createObjectURL","PageConfig","getOption","appLicensesUrl","URLExt","join","getBaseUrl","labExtensionsUrl","bundle","fetch","json","err","console","warn","federated","parse","promises","ext","push","_getOneFederated","Promise","all","url","name","response"],"sourceRoot":""}